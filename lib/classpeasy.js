// Generated by CoffeeScript 1.6.2
(function() {
  var hasOwnProperty, isMatcher, parse, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  hasOwnProperty = Object.hasOwnProperty;

  isMatcher = function(item) {
    return typeof item === "function";
  };

  exports.Parser = (function() {
    function _Class() {}

    _Class.prototype.construcotr = function() {
      this.originalRules = {};
      this.recursiveRules = {};
      this.symbolDescedentsMap = {};
      this.symbolToTagMap = {};
      return this.tags = {};
    };

    _Class.prototype.parse = function(data, root) {
      this.parseCache = {};
      this.functionCache = {};
      this.text = data;
      this.textLength = this.text.length;
      this.cursor = 0;
      root = root || this.rootSymbol;
      return this[root](0);
    };

    _Class.prototype.addParentChildrens = function(parentChildren) {
      var children, list, map, name, parent, _i, _len, _ref, _ref1;

      map = (_ref = this.parentToChildren) != null ? _ref : this.parentToChildren = {};
      for (parent in parentChildren) {
        children = parentChildren[parent];
        list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          name = children[_i];
          if (__indexOf.call(list, name) < 0) {
            list.push(name);
          }
        }
      }
      return null;
    };

    _Class.prototype.addRecursiveCircles = function() {
      var circle, i, j, length, list, map, name, parent, recursiveCircles, _i, _len, _ref, _ref1;

      recursiveCircles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      map = (_ref = this.parentToChildren) != null ? _ref : this.parentToChildren = {};
      for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
        circle = recursiveCircles[_i];
        i = 0;
        length = circle.length;
        while (i < length) {
          if (i === length - 1) {
            j = 0;
          } else {
            j = i + 1;
          }
          name = circle[i];
          parent = circle[j];
          list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
          if (__indexOf.call(list, name) < 0) {
            list.push(name);
          }
          i++;
        }
      }
      return null;
    };

    _Class.prototype.computeLeftRecursives = function() {
      var addDescendents, descendents, meetTable, parentToChildren, symbol;

      parentToChildren = this.parentToChildren;
      addDescendents = function(symbol, meetTable, descedents) {
        var child, children, _i, _len, _results;

        children = parentToChildren[symbol];
        _results = [];
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          if (__indexOf.call(descedents, child) < 0) {
            descedents.push(child);
          }
          if (!meetTable[child]) {
            _results.push(addDescendents(child, meetTable, descedents));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      this.symbolDescedentsMap = {};
      for (symbol in parentToChildren) {
        meetTable = {};
        meetTable[symbol] = true;
        descendents = this.symbolDescedentsMap[symbol] = [];
        addDescendents(symbol, meetTable, descendents);
        if (__indexOf.call(descendents, symbol) >= 0) {
          this.originalRules[symbol] = this[symbol];
          this[symbol] = recursive(symbol);
        }
      }
      return this.symbolDescedentsMap;
    };

    _Class.prototype.recursive = function(symbol) {
      var rule;

      rule = this.originalRules[symbol];
      return function(start) {
        var child, hash, m, result, _base, _i, _j, _len, _len1, _ref, _ref1, _ref2;

        _ref = this.symbolDescedentsMap[symbol];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          this[child] = this.originalRules[child];
        }
        hash = symbol + start;
        m = (_ref1 = (_base = this.parseCache)[hash]) != null ? _ref1 : _base[hash] = [void 0, -1];
        if (m[1] >= 0) {
          this.cursor = m[1];
          return m[0];
        }
        while (1) {
          result = rule(start);
          if (m[1] < 0) {
            m[0] = result;
            if (result) {
              m[1] = this.cursor;
            } else {
              m[1] = start;
            }
          } else {
            if (m[1] === this.cursor) {
              m[0] = result;
              return result;
            } else if (this.cursor < m[1]) {
              m[0] = result;
              this.cursor = m[1];
              return result;
            } else {
              m[0] = result;
              m[1] = this.cursor;
            }
          }
        }
        _ref2 = this.symbolDescedentsMap[symbol];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          child = _ref2[_j];
          this[child] = this.recursiveRules[child];
        }
        return result;
      };
    };

    _Class.prototype.memo = function(symbol) {
      return function(start) {
        var hash, m;

        hash = symbol + start;
        m = this.parseCache[hash];
        if (m) {
          return m[0];
        }
      };
    };

    _Class.prototype.setMemorizeRules = function(symbols) {
      var symbol, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = symbols.length; _i < _len; _i++) {
        symbol = symbols[_i];
        this.originalRules[symbol] = this[symbol];
        _results.push(this[symbol] = memorize(symbol));
      }
      return _results;
    };

    _Class.prototype.memorize = function(symbol) {
      var rule, tag;

      tag = this.symbolToTagMap[symbol];
      rule = this.originalRules[symbol];
      return function(start) {
        var hash, m, result;

        hash = tag + start;
        m = this.parseCache[hash];
        if (m) {
          this.cursor = m[1];
          return m[0];
        } else {
          result = rule(start);
          this.parseCache[hash] = [result, this.cursor];
          return result;
        }
      };
    };

    _Class.prototype.setMemoTag = function(symbol) {
      var i, tag;

      i = 1;
      while (1) {
        if (hasOwnProperty.call(this.tags, symbol.slice(0, i))) {
          i++;
        } else {
          break;
        }
      }
      tag = symbol.slice(0, i);
      this.symbolToTagMap[symbol] = tag;
      return this.tags[tag] = true;
    };

    _Class.prototype.andp = function(items) {
      var item;

      items = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!isMatcher(item)) {
            _results.push(literal(item));
          } else {
            _results.push(item);
          }
        }
        return _results;
      })();
      return function(start) {
        var result, _i, _len;

        this.cursor = start;
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!(result = item(this.cursor))) {
            return;
          }
        }
        return result;
      };
    };

    _Class.prototype.orp = function() {
      var item, items;

      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      items = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!isMatcher(item)) {
            _results.push(literal(item));
          } else {
            _results.push(item);
          }
        }
        return _results;
      })();
      return function(start) {
        var result, _i, _len;

        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (result = item(start)) {
            return result;
          }
        }
        return result;
      };
    };

    _Class.prototype.notp = function(item) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        return !item(start);
      };
    };

    _Class.prototype.any = function(item) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var result, x;

        result = [];
        this.cursor = start;
        while ((x = item(this.cursor))) {
          result.push(x);
        }
        return result;
      };
    };

    _Class.prototype.some = function(item) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var result, x;

        result = [];
        this.cursor = start;
        if (!(x = item(this.cursor))) {
          return x;
        }
        while (1) {
          result.push(x);
          x = item(this.cursor);
          if (!x) {
            break;
          }
        }
        return result;
      };
    };

    _Class.prototype.may = function(item) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var x;

        this.cursor = start;
        if (x = item(this.cursor)) {
          return x;
        } else {
          this.cursor = start;
          return true;
        }
      };
    };

    _Class.prototype.follow = function(item) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var x;

        this.cursor = start;
        if (x = item(this.cursor)) {
          this.cursor = start;
          return x;
        }
      };
    };

    _Class.prototype.times = function(item, n) {
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var i, x;

        this.cursor = start;
        i = 0;
        while (i++ < n) {
          if (x = item(this.cursor)) {
            result.push(x);
          } else {
            return;
          }
        }
        return result;
      };
    };

    _Class.prototype.seperatedList = function(item, separator) {
      if (separator == null) {
        separator = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(item);
      }
      if (!isMatcher(separator)) {
        separator = literal(separator);
      }
      return function(start) {
        var result, x;

        this.cursor = start;
        result = [];
        x = item(this.cursor);
        if (!x) {
          return;
        }
        while (1) {
          result.push(x);
          if (!(x = item(this.cursor))) {
            break;
          }
        }
        return result;
      };
    };

    _Class.prototype.timesSeperatedList = function(item, n, separator) {
      if (separator == null) {
        separator = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(item);
      }
      if (!isMatcher(separator)) {
        separator = literal(separator);
      }
      return function(start) {
        var i, result, x;

        this.cursor = start;
        result = [];
        x = item(this.cursor);
        if (!x) {
          return;
        }
        i = 1;
        while (i++ < n) {
          result.push(x);
          if (!(x = item(this.cursor))) {
            break;
          }
        }
        return result;
      };
    };

    return _Class;

  })();

  exports.TextParser = (function(_super) {
    var upper, upper_;

    __extends(_Class, _super);

    function _Class() {
      _ref = _Class.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    _Class.prototype.literal = function(string) {
      return function(start) {
        var len, stop;

        len = string.length;
        if (this.text.slice(start, stop = start + len) === string) {
          this.cursor = stop;
          return true;
        }
      };
    };

    _Class.prototype.literal_ = function(string) {
      return function(start) {
        var len, stop;

        len = string.length;
        if (this.text.slice(this.cursor, stop = this.cursor + len) === string) {
          this.cursor = stop;
          return true;
        }
      };
    };

    _Class.prototype.char = function(c) {
      return function(start) {
        if (this.text[start] === c) {
          this.cursor = start + 1;
          return c;
        }
      };
    };

    _Class.prototype.char_ = function(c) {
      return function() {
        if (this.text[this.cursor] === c) {
          this.cursor++;
          return c;
        }
      };
    };

    _Class.prototype.spaces = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (this.text[this.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    _Class.prototype.spaces_ = function() {
      var len;

      len = 0;
      while (1) {
        switch (this.text[this.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };

    _Class.prototype.spaces1 = function(start) {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (this.text[this.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return this.cursor = this.cursor;
        return len;
      }
    };

    _Class.prototype.spaces1_ = function() {
      var len;

      len = 0;
      this.cursor = start;
      while (1) {
        switch (this.text[this.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return this.cursor = this.cursor;
        return len;
      }
    };

    _Class.prototype.wrap = function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(item);
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(this.cursor) && right(this.cursor))) {
          return result;
        }
      };
    };

    _Class.prototype.identifierLetter = function(start) {
      var c;

      start = this.cursor;
      c = this.text[this.cursor];
      if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        this.cursor++;
        return true;
      }
    };

    _Class.prototype.identifierLetter_ = function() {
      var c;

      c = this.text[this.cursor];
      if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        this.cursor++;
        return true;
      }
    };

    _Class.prototype.followIdentifierLetter_ = function() {
      var c;

      c = this.text[this.cursor];
      return c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');
    };

    _Class.prototype.digit = function(start) {
      var c;

      c = this.text[start];
      if (('0' <= c && c <= '9')) {
        return this.cursor = start + 1;
      }
    };

    _Class.prototype.digit_ = function() {
      var c;

      c = this.text[this.cursor];
      if (('0' <= c && c <= '9')) {
        return this.cursor++;
      }
    };

    _Class.prototype.letter = function(start) {
      var c;

      c = this.text[start];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return this.cursor = start + 1;
      }
    };

    _Class.prototype.letter_ = function() {
      var c;

      c = this.text[this.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return this.cursor++;
      }
    };

    _Class.prototype.lower = function(start) {
      var c;

      c = this.text[start];
      if (('a' <= c && c <= 'z')) {
        return this.cursor = start + 1;
      }
    };

    _Class.prototype.lower_ = function() {
      var c;

      c = this.text[this.cursor];
      if (('a' <= c && c <= 'z')) {
        return this.cursor++;
      }
    };

    upper = function(start) {
      var c;

      c = this.text[start];
      if (('A' <= c && c <= 'Z')) {
        return this.cursor = start + 1;
      }
    };

    upper_ = function() {
      var c;

      c = this.text[this.cursor];
      if (('A' <= c && c <= 'Z')) {
        return this.cursor++;
      }
    };

    _Class.prototype.identifier = function(start) {
      var c;

      this.cursor = start;
      c = this.text[this.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
        this.cursor++;
      } else {
        return;
      }
      while (1) {
        c = this.text[this.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
          this.cursor++;
        } else {
          break;
        }
      }
      return true;
    };

    _Class.prototype.identifier_ = function() {
      var c;

      c = this.text[this.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
        this.cursor++;
      } else {
        return;
      }
      while (1) {
        c = this.text[this.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
          this.cursor++;
        } else {
          break;
        }
      }
      return true;
    };

    return _Class;

  })(Parser);

  parse = function(text) {
    var MyParser, a, b, memoA, parser, x, _ref1;

    a = TextParser.prototype.char('a');
    b = TextParser.prototype.char('b');
    x = TextParser.prototype.char('x');
    memoA = TextParser.prototype.memo('A');
    MyParser = (function(_super) {
      __extends(MyParser, _super);

      function MyParser() {
        _ref1 = MyParser.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      MyParser.prototype.A = function(start) {
        var m, memoResult;

        return (memoResult = m = this.B(start)) && x(this.cursor) && m + 'x' || memoResult || a(start);
      };

      MyParser.prototype.B = function(start) {
        return this.C(start);
      };

      MyParser.prototype.C = function(start) {
        return memoA(start) || b(start);
      };

      MyParser.prototype.rootSymbol = 'A';

      return MyParser;

    })(TextParser);
    parser = new MyParser();
    parser.addRecursiveCircles(rules, ['A', 'B', 'C']);
    parser.computeLeftRecursives(rules);
    return parser.parse(text, rules);
  };

  exports.isdigit = function(c) {
    return ('0' <= c && c <= '9');
  };

  exports.islower = function(c) {
    return ('a' <= c && c <= 'z');
  };

  exports.isupper = function(c) {
    return ('A' <= c && c <= 'Z');
  };

  exports.isIdentifierLetter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_';
  };

}).call(this);

/*
//@ sourceMappingURL=classpeasy.map
*/
