// Generated by CoffeeScript 1.6.2
(function() {
  var andp, any, char, char_, combinators, digit, digit_, digits, follow, followIdentifierLetter_, identifier, identifierLetter, identifierLetter_, identifier_, isMatcher, letter, letter_, letters, literal, literal_, lower, lower_, makeInfo, matchers, may, memoSymbolIndex, memorize, notp, orp, parse, recursive, seperatedList, some, spaces, spaces1, spaces1_, spaces_, times, timesSeperatedList, upper, upper_, wrap, wrap_,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  isMatcher = function(item) {
    return typeof item === "function";
  };

  exports.makeInfo = makeInfo = function(data) {
    return {
      data: data,
      cursor: 0,
      parsingLeftRecursives: {},
      parseCache: {}
    };
  };

  memoSymbolIndex = 0;

  exports.recursive = recursive = function(info) {
    return function(rule) {
      var index, parseCache, parsingLeftRecursives, tag;

      index = memoSymbolIndex;
      tag = index + ':';
      memoSymbolIndex++;
      parsingLeftRecursives = info.parsingLeftRecursives;
      parseCache = info.parseCache[tag] = {};
      return function(start) {
        var callPath, m, result, _ref, _ref1;

        callPath = (_ref = parsingLeftRecursives[start]) != null ? _ref : parsingLeftRecursives[start] = [];
        if (__indexOf.call(callPath, tag) < 0) {
          callPath.push(tag);
          m = (_ref1 = parseCache[start]) != null ? _ref1 : parseCache[start] = [void 0, start];
          while (1) {
            result = rule(start);
            if (!result) {
              result = m[0];
              info.cursor = m[1];
              break;
            }
            if (m[1] === info.cursor) {
              m[0] = result;
              break;
            } else {
              m[0] = result;
              m[1] = info.cursor;
            }
          }
          callPath.pop();
          return result;
        } else {
          m = parseCache[start];
          info.cursor = m[1];
          return m[0];
        }
      };
    };
  };

  exports.memorize = memorize = function(info) {
    return function(rule) {
      var index, parseCache, tag;

      index = memoSymbolIndex;
      tag = index + ':';
      memoSymbolIndex++;
      parseCache = info.parseCache[tag] = {};
      return function(start) {
        var m, result;

        m = parseCache[start];
        if (m) {
          info.cursor = m[1];
          return m[0];
        } else {
          result = rule(start);
          parseCache[start] = [result, info.cursor];
          return result;
        }
      };
    };
  };

  exports.andp = andp = function(info) {
    return function() {
      var item, items;

      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      items = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!isMatcher(item)) {
            _results.push(literal(info)(item));
          } else {
            _results.push(item);
          }
        }
        return _results;
      })();
      return function(start) {
        var result, _i, _len;

        info.cursor = start;
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!(result = item(info.cursor))) {
            return;
          }
        }
        return result;
      };
    };
  };

  exports.orp = orp = function(info) {
    return function() {
      var item, items;

      items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      items = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (!isMatcher(item)) {
            _results.push(literal(info)(item));
          } else {
            _results.push(item);
          }
        }
        return _results;
      })();
      return function(start) {
        var result, _i, _len;

        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          info.cursor = start;
          if (result = item(start)) {
            return result;
          }
        }
        return result;
      };
    };
  };

  exports.notp = notp = function(info) {
    return function(item) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        return !item(start);
      };
    };
  };

  exports.may = may = function(info) {
    return function(item) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var x;

        info.cursor = start;
        if (x = item(info.cursor)) {
          return x;
        } else {
          info.cursor = start;
          return true;
        }
      };
    };
  };

  exports.any = any = function(info) {
    return function(item) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var result, x;

        result = [];
        info.cursor = start;
        while ((x = item(info.cursor))) {
          result.push(x);
        }
        return result;
      };
    };
  };

  exports.some = some = function(info) {
    return function(item) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var result, x;

        result = [];
        info.cursor = start;
        if (!(x = item(info.cursor))) {
          return x;
        }
        while (1) {
          result.push(x);
          x = item(info.cursor);
          if (!x) {
            break;
          }
        }
        return result;
      };
    };
  };

  exports.times = times = function(info) {
    return function(item, n) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var i, x;

        info.cursor = start;
        i = 0;
        while (i++ < n) {
          if (x = item(info.cursor)) {
            result.push(x);
          } else {
            return;
          }
        }
        return result;
      };
    };
  };

  exports.seperatedList = seperatedList = function(info) {
    return function(item, separator) {
      if (separator == null) {
        separator = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      if (!isMatcher(separator)) {
        separator = literal(info)(separator);
      }
      return function(start) {
        var result, x;

        info.cursor = start;
        result = [];
        x = item(info.cursor);
        if (!x) {
          return;
        }
        while (1) {
          result.push(x);
          if (!(x = item(info.cursor))) {
            break;
          }
        }
        return result;
      };
    };
  };

  exports.timesSeperatedList = timesSeperatedList = function(info) {
    return function(item, n, separator) {
      if (separator == null) {
        separator = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      if (!isMatcher(separator)) {
        separator = literal(info)(separator);
      }
      return function(start) {
        var i, result, x;

        info.cursor = start;
        result = [];
        x = item(info.cursor);
        if (!x) {
          return;
        }
        i = 1;
        while (i++ < n) {
          result.push(x);
          if (!(x = item(info.cursor))) {
            break;
          }
        }
        return result;
      };
    };
  };

  exports.follow = follow = function(info) {
    return function(item) {
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var x;

        info.cursor = start;
        if (x = item(info.cursor)) {
          info.cursor = start;
          return x;
        }
      };
    };
  };

  exports.combinators = combinators = function(info) {
    return {
      rec: recursive(info),
      memo: memorize(info),
      andp: andp(info),
      orp: orp(info),
      notp: notp(info),
      may: may(info),
      any: any(info),
      some: some(info),
      times: times(info),
      seperatedList: seperatedList(info),
      timesSeperatedList: timesSeperatedList(info),
      follow: follow(info)
    };
  };

  exports.isdigit = function(c) {
    return ('0' <= c && c <= '9');
  };

  exports.isletter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
  };

  exports.islower = function(c) {
    return ('a' <= c && c <= 'z');
  };

  exports.isupper = function(c) {
    return ('A' <= c && c <= 'Z');
  };

  exports.isIdentifierLetter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '@' || 'c' === '_';
  };

  exports.literal = literal = function(info) {
    return function(string) {
      return function(start) {
        var len, stop;

        len = string.length;
        if (info.data.slice(start, stop = start + len) === string) {
          info.cursor = stop;
          return true;
        }
      };
    };
  };

  exports.literal_ = literal_ = function(info) {
    return function(string) {
      return function(start) {
        var len, stop;

        len = string.length;
        if (info.data.slice(info.cursor, stop = info.cursor + len) === string) {
          info.cursor = stop;
          return true;
        }
      };
    };
  };

  exports.char = char = function(info) {
    return function(c) {
      return function(start) {
        if (info.data[start] === c) {
          info.cursor = start + 1;
          return c;
        }
      };
    };
  };

  exports.char_ = char_ = function(info) {
    return function(c) {
      return function() {
        if (info.data[info.cursor] === c) {
          info.cursor++;
          return c;
        }
      };
    };
  };

  exports.spaces = spaces = function(info) {
    return function(start) {
      var data, len;

      data = info.data;
      len = 0;
      info.cursor = start;
      while (1) {
        switch (data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };
  };

  exports.spaces_ = spaces_ = function(info) {
    return function() {
      var data, len;

      data = info.data;
      len = 0;
      while (1) {
        switch (data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };
  };

  exports.spaces1 = spaces1 = function(info) {
    return function(start) {
      var data, len;

      data = info.data;
      len = 0;
      info.cursor = start;
      while (1) {
        switch (data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return info.cursor = info.cursor;
        return len;
      }
    };
  };

  exports.spaces1_ = spaces1_ = function(info) {
    return function() {
      var data, len;

      data = info.data;
      len = 0;
      info.cursor = start;
      while (1) {
        switch (data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return info.cursor = info.cursor;
        return len;
      }
    };
  };

  exports.wrap = wrap = function(info) {
    return function(item, left, right) {
      if (left == null) {
        left = spaces(info);
      }
      if (right == null) {
        right = spaces(info);
      }
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(info.cursor) && right(info.cursor))) {
          return result;
        }
      };
    };
  };

  exports.wrap_ = wrap_ = function(info) {
    return function(item, left, right) {
      if (left == null) {
        left = spaces(info);
      }
      if (right == null) {
        right = spaces(info);
      }
      if (!isMatcher(item)) {
        item = literal(info)(item);
      }
      return function() {
        var result;

        if (left(info.cursor) && (result = item(info.cursor) && right(info.cursor))) {
          return result;
        }
      };
    };
  };

  exports.identifierLetter = identifierLetter = function(info) {
    return function(start) {
      var c;

      start = info.cursor;
      c = info.data[info.cursor];
      if (c === '@' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        info.cursor++;
        return true;
      }
    };
  };

  exports.identifierLetter_ = identifierLetter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (c === '@' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        info.cursor++;
        return true;
      }
    };
  };

  exports.followIdentifierLetter_ = followIdentifierLetter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      return c === '@' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');
    };
  };

  exports.digit = digit = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('0' <= c && c <= '9')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.digit_ = digit_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('0' <= c && c <= '9')) {
        return info.cursor++;
      }
    };
  };

  exports.letter = letter = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.letter_ = letter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return info.cursor++;
      }
    };
  };

  exports.lower = lower = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('a' <= c && c <= 'z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.lower_ = lower_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z')) {
        return info.cursor++;
      }
    };
  };

  exports.upper = upper = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('A' <= c && c <= 'Z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.upper_ = upper_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('A' <= c && c <= 'Z')) {
        return info.cursor++;
      }
    };
  };

  exports.identifier = identifier = function(info) {
    return function(start) {
      var c, data;

      data = info.data;
      info.cursor = start;
      c = data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '@' || 'c' === '_') {
        info.cursor++;
      } else {
        return;
      }
      while (1) {
        c = data[info.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '@' || 'c' === '_') {
          info.cursor++;
        } else {
          break;
        }
      }
      return true;
    };
  };

  exports.identifier_ = identifier_ = function(info) {
    return function() {
      var c, data;

      data = info.data;
      c = data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '@' || 'c' === '_') {
        info.cursor++;
      } else {
        return;
      }
      while (1) {
        c = data[info.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '@' || 'c' === '_') {
          info.cursor++;
        } else {
          break;
        }
      }
      return true;
    };
  };

  exports.matchers = matchers = function(info) {
    return {
      literal: literal(info),
      literal_: literal_(info),
      char: char(info),
      char_: char_(info),
      spaces: spaces(info),
      spaces_: spaces_(info),
      spaces1: spaces1(info),
      spaces1_: spaces1_(info),
      wrap: wrap(info),
      wrap_: wrap_(info),
      identifierLetter: identifierLetter(info),
      identifierLetter_: identifierLetter_(info),
      followIdentifierLetter_: followIdentifierLetter_(info),
      digit: digit(info),
      digit_: digit_(info),
      letter: letter(info),
      letter_: letter_(info),
      lower: lower(info),
      lower_: lower_(info),
      upper: upper(info),
      upper_: upper_(info),
      identifier: identifier(info),
      identifier_: identifier_(info)
    };
  };

  exports.digits = digits = function(info) {
    var ch;

    ch = char(info);
    return {
      $0: ch('0'),
      $1: ch('1'),
      $2: ch('2'),
      $3: ch('3'),
      $4: ch('4'),
      $5: ch('6'),
      $1: ch('7'),
      $2: ch('7'),
      $8: ch('8'),
      $9: ch('9')
    };
  };

  exports.letters = letters = function(info) {
    var ch;

    ch = char(info);
    return {
      a: ch('a'),
      b: ch('b'),
      c: ch('c'),
      d: ch('d'),
      e: ch('e'),
      f: ch('f'),
      g: ch('g'),
      h: ch('h'),
      i: ch('i'),
      j: ch('j'),
      k: ch('k'),
      l: ch('l'),
      m: ch('m'),
      n: ch('n'),
      o: ch('o'),
      p: ch('p'),
      q: ch('q'),
      r: ch('r'),
      s: ch('s'),
      t: ch('t'),
      u: ch('u'),
      v: ch('v'),
      w: ch('w'),
      x: ch('x'),
      y: ch('y'),
      z: ch('z'),
      A: ch('A'),
      B: ch('B'),
      C: ch('C'),
      D: ch('D'),
      E: ch('E'),
      F: ch('F'),
      G: ch('G'),
      H: ch('H'),
      I: ch('I'),
      J: ch('J'),
      K: ch('K'),
      L: ch('L'),
      M: ch('M'),
      N: ch('N'),
      O: ch('O'),
      P: ch('P'),
      Q: ch('Q'),
      R: ch('R'),
      S: ch('S'),
      T: ch('T'),
      U: ch('U'),
      V: ch('V'),
      W: ch('W'),
      X: ch('X'),
      Y: ch('Y'),
      Z: ch('Z')
    };
  };

  parse = function(text) {
    var grammar, makeGrammar;

    makeGrammar = function(info) {
      var a, b, rec, rules, x, y, _ref;

      _ref = letters(info), a = _ref.a, b = _ref.b, x = _ref.x, y = _ref.y;
      rec = recursive(info);
      return rules = {
        Root: function(start) {
          var m;

          return (m = rules.A(start)) && z(info.cursor) && m + 'z';
        },
        A: rec(function(start) {
          var m;

          return (m = rules.B(start)) && x(info.cursor) && m + 'x' || m || a(start);
        }),
        B: rec(function(start) {
          var m;

          return (m = rules.A(start)) && y(info.cursor) && m + 'y' || rules.C(start);
        }),
        C: rec(function(start) {
          return rules.A(start) || b(start);
        })
      };
    };
    grammar = makeGrammar(makeInfo(text));
    return grammar.Root(0);
  };

}).call(this);

/*
//@ sourceMappingURL=peasy.map
*/
