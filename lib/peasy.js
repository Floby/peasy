// Generated by CoffeeScript 1.6.2
(function() {
  var cursor, followIdentifierLetter_, functionCache, grammar, hasOwnProperty, identifierLetter, identifierLetter_, isIdentifierLetter, isMatcher, literal, literal_, memo, memorize, originalRules, parse, parseCache, recursive, recursiveRules, setMemoTag, setMemorizeRules, symbolDescedentsMap, symbolToTagMap, tags, text, textLength, _parse,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  text = '';

  textLength = 0;

  cursor = 0;

  grammar = void 0;

  originalRules = {};

  recursiveRules = {};

  symbolDescedentsMap = {};

  symbolToTagMap = {};

  tags = {};

  parseCache = {};

  functionCache = {};

  hasOwnProperty = Object.hasOwnProperty;

  exports.initialize = function() {
    parseCache = {};
    functionCache = {};
    originalRules = {};
    recursiveRules = {};
    symbolDescedentsMap = {};
    symbolToTagMap = {};
    tags = {};
    return parseCache = {};
  };

  exports.parse = _parse = function(data, aGrammar, root) {
    text = data;
    textLength = text.length;
    cursor = 0;
    root = root || aGrammar.rootSymbol;
    grammar = aGrammar;
    return grammar[root](0);
  };

  parse = function(text) {
    var a, b, memoA, rules, x;

    a = char('a');
    b = char('b');
    x = char('x');
    memoA = memo('A');
    rules = {
      A: function(start) {
        var m, memoResult;

        return (memoResult = m = rules.B(start)) && x(p.cur()) && m + 'x' || memoResult || a(start);
      },
      B: function(start) {
        return rules.C(start);
      },
      C: function(start) {
        return memoA(start) || b(start);
      },
      rootSymbol: 'A'
    };
    initialize();
    addRecursiveCircles(rules, ['A', 'B', 'C']);
    computeLeftRecursives(rules);
    return _parse(text, rules);
  };

  exports.addParentChildrens = function(grammar, parentChildren) {
    var children, list, map, name, parent, _i, _len, _ref, _ref1;

    map = (_ref = grammar.parentToChildren) != null ? _ref : grammar.parentToChildren = {};
    for (parent in parentChildren) {
      children = parentChildren[parent];
      list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        name = children[_i];
        if (__indexOf.call(list, name) < 0) {
          list.push(name);
        }
      }
    }
    return null;
  };

  exports.addRecursiveCircles = function() {
    var circle, grammar, i, j, length, list, map, name, parent, recursiveCircles, _i, _len, _ref, _ref1;

    grammar = arguments[0], recursiveCircles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    map = (_ref = grammar.parentToChildren) != null ? _ref : grammar.parentToChildren = {};
    for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
      circle = recursiveCircles[_i];
      i = 0;
      length = circle.length;
      while (i < length) {
        if (i === length - 1) {
          j = 0;
        } else {
          j = i + 1;
        }
        name = circle[i];
        parent = circle[j];
        list = (_ref1 = map[parent]) != null ? _ref1 : map[parent] = [];
        if (__indexOf.call(list, name) < 0) {
          list.push(name);
        }
        i++;
      }
    }
    return null;
  };

  exports.computeLeftRecursives = function(grammar) {
    var addDescendents, descendents, meetTable, parentToChildren, symbol;

    parentToChildren = grammar.parentToChildren;
    addDescendents = function(symbol, meetTable, descedents) {
      var child, children, _i, _len, _results;

      children = parentToChildren[symbol];
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        if (__indexOf.call(descedents, child) < 0) {
          descedents.push(child);
        }
        if (!meetTable[child]) {
          _results.push(addDescendents(child, meetTable, descedents));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    symbolDescedentsMap = {};
    for (symbol in parentToChildren) {
      meetTable = {};
      meetTable[symbol] = true;
      descendents = symbolDescedentsMap[symbol] = [];
      addDescendents(symbol, meetTable, descendents);
      if (__indexOf.call(descendents, symbol) >= 0) {
        originalRules[symbol] = grammar[symbol];
        grammar[symbol] = recursive(symbol);
      }
    }
    return symbolDescedentsMap;
  };

  exports.recursive = recursive = function(symbol) {
    var rule;

    rule = originalRules[symbol];
    return function(start) {
      var child, hash, m, result, _i, _j, _len, _len1, _ref, _ref1, _ref2;

      _ref = symbolDescedentsMap[symbol];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        grammar[child] = originalRules[child];
      }
      hash = symbol + start;
      m = (_ref1 = parseCache[hash]) != null ? _ref1 : parseCache[hash] = [void 0, -1];
      if (m[1] >= 0) {
        cursor = m[1];
        return m[0];
      }
      while (1) {
        result = rule(start);
        if (m[1] < 0) {
          m[0] = result;
          if (result) {
            m[1] = cursor;
          } else {
            m[1] = start;
          }
        } else {
          if (m[1] === cursor) {
            m[0] = result;
            return result;
          } else if (cursor < m[1]) {
            m[0] = result;
            cursor = m[1];
            return result;
          } else {
            m[0] = result;
            m[1] = cursor;
          }
        }
      }
      _ref2 = symbolDescedentsMap[symbol];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        child = _ref2[_j];
        grammar[child] = recursiveRules[child];
      }
      return result;
    };
  };

  exports.memo = memo = function(symbol) {
    return function(start) {
      var hash, m;

      hash = symbol + start;
      m = parseCache[hash];
      if (m) {
        return m[0];
      }
    };
  };

  setMemorizeRules = function(grammar, symbols) {
    var symbol, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = symbols.length; _i < _len; _i++) {
      symbol = symbols[_i];
      originalRules[symbol] = grammar[symbol];
      _results.push(grammar[symbol] = memorize(symbol));
    }
    return _results;
  };

  memorize = function(symbol) {
    var rule, tag;

    tag = symbolToTagMap[symbol];
    rule = originalRules[symbol];
    return function(start) {
      var hash, m, result;

      hash = tag + start;
      m = parseCache[hash];
      if (m) {
        cursor = m[1];
        return m[0];
      } else {
        result = rule(start);
        parseCache[hash] = [result, cursor];
        return result;
      }
    };
  };

  setMemoTag = function(symbol) {
    var i, tag;

    i = 1;
    while (1) {
      if (hasOwnProperty.call(tags, symbol.slice(0, i))) {
        i++;
      } else {
        break;
      }
    }
    tag = symbol.slice(0, i);
    symbolToTagMap[symbol] = tag;
    return tags[tag] = true;
  };

  isMatcher = function(item) {
    return typeof item === "function";
  };

  exports.andp = function(items) {
    var item;

    items = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!isMatcher(item)) {
          _results.push(literal(item));
        } else {
          _results.push(item);
        }
      }
      return _results;
    })();
    return function(start) {
      var result, _i, _len;

      cursor = start;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!(result = item(cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function() {
    var item, items;

    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    items = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!isMatcher(item)) {
          _results.push(literal(item));
        } else {
          _results.push(item);
        }
      }
      return _results;
    })();
    return function(start) {
      var result, _i, _len;

      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (result = item(start)) {
          return result;
        }
      }
      return result;
    };
  };

  exports.notp = function(item) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      return !item(start);
    };
  };

  exports.any = function(item) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var result, x;

      result = [];
      cursor = start;
      while ((x = item(cursor))) {
        result.push(x);
      }
      return result;
    };
  };

  exports.some = function(item) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var result, x;

      result = [];
      cursor = start;
      if (!(x = item(cursor))) {
        return x;
      }
      while (1) {
        result.push(x);
        x = item(cursor);
        if (!x) {
          break;
        }
      }
      return result;
    };
  };

  exports.may = exports.optional = function(item) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var x;

      cursor = start;
      if (x = item(cursor)) {
        return x;
      } else {
        cursor = start;
        return true;
      }
    };
  };

  exports.follow = function(item) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var x;

      cursor = start;
      if (x = item(cursor)) {
        cursor = start;
        return x;
      }
    };
  };

  exports.times = function(item, n) {
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var i, x;

      cursor = start;
      i = 0;
      while (i++ < n) {
        if (x = item(cursor)) {
          result.push(x);
        } else {
          return;
        }
      }
      return result;
    };
  };

  exports.seperatedList = function(item, separator) {
    if (separator == null) {
      separator = spaces;
    }
    if (!isMatcher(item)) {
      item = literal(item);
    }
    if (!isMatcher(separator)) {
      separator = literal(separator);
    }
    return function(start) {
      var result, x;

      cursor = start;
      result = [];
      x = item(cursor);
      if (!x) {
        return;
      }
      while (1) {
        result.push(x);
        if (!(x = item(cursor))) {
          break;
        }
      }
      return result;
    };
  };

  exports.timesSeperatedList = function(item, n, separator) {
    if (separator == null) {
      separator = spaces;
    }
    if (!isMatcher(item)) {
      item = literal(item);
    }
    if (!isMatcher(separator)) {
      separator = literal(separator);
    }
    return function(start) {
      var i, result, x;

      cursor = start;
      result = [];
      x = item(cursor);
      if (!x) {
        return;
      }
      i = 1;
      while (i++ < n) {
        result.push(x);
        if (!(x = item(cursor))) {
          break;
        }
      }
      return result;
    };
  };

  exports.literal = literal = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.literal_ = literal_ = function(string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (text.slice(cursor, stop = cursor + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  exports.char = function(c) {
    return function(start) {
      if (text[start] === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  exports.char_ = function(c) {
    return function() {
      if (text[cursor] === c) {
        cursor++;
        return c;
      }
    };
  };

  exports.spaces = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces_ = function() {
    var len;

    len = 0;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  exports.spaces1 = function(start) {
    var len;

    len = 0;
    cursor = start;
    text = text;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.spaces1_ = function() {
    var len;

    len = 0;
    cursor = start;
    while (1) {
      switch (text[cursor++]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return cursor = cursor;
      return len;
    }
  };

  exports.wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    if (!isMatcher(item)) {
      item = literal(item);
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  identifierLetter = function(start) {
    var c;

    start = cursor;
    c = text[cursor];
    if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
      cursor++;
      return true;
    }
  };

  identifierLetter_ = function() {
    var c;

    c = text[cursor];
    if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
      cursor++;
      return true;
    }
  };

  followIdentifierLetter_ = function() {
    var c;

    c = text[cursor];
    return c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');
  };

  isIdentifierLetter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_';
  };

  exports.isdigit = function(c) {
    return ('0' <= c && c <= '9');
  };

  exports.digit = function(start) {
    var c;

    c = text[start];
    if (('0' <= c && c <= '9')) {
      return cursor = start + 1;
    }
  };

  exports.digit_ = function() {
    var c;

    c = text[cursor];
    if (('0' <= c && c <= '9')) {
      return cursor++;
    }
  };

  exports.isletter = exports.isalpha = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
  };

  exports.letter = exports.alpha = function(start) {
    var c;

    c = text[start];
    if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
      return cursor = start + 1;
    }
  };

  exports.letter_ = exports.alpha_ = function() {
    var c;

    c = text[cursor];
    if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
      return cursor++;
    }
  };

  exports.islower = function(c) {
    return ('a' <= c && c <= 'z');
  };

  exports.lower = function(start) {
    var c;

    c = text[start];
    if (('a' <= c && c <= 'z')) {
      return cursor = start + 1;
    }
  };

  exports.lower_ = function() {
    var c;

    c = text[cursor];
    if (('a' <= c && c <= 'z')) {
      return cursor++;
    }
  };

  exports.isupper = function(c) {
    return ('A' <= c && c <= 'Z');
  };

  exports.upper = function(start) {
    var c;

    c = text[start];
    if (('A' <= c && c <= 'Z')) {
      return cursor = start + 1;
    }
  };

  exports.upper_ = function(start) {
    var c;

    c = text[cursor];
    if (('A' <= c && c <= 'Z')) {
      return cursor++;
    }
  };

  exports.identifier = function(start) {
    var c;

    cursor = start;
    c = text[cursor];
    if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
      cursor++;
    } else {
      return;
    }
    while (1) {
      c = text[cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
        cursor++;
      } else {
        break;
      }
    }
    return true;
  };

  exports.identifier_ = function(start) {
    var c;

    c = text[cursor];
    if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
      cursor++;
    } else {
      return;
    }
    while (1) {
      c = text[cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
        cursor++;
      } else {
        break;
      }
    }
    return true;
  };

  exports.gettext = function() {
    return text;
  };

  exports.getcursor = exports.cur = function() {
    return cursor;
  };

  exports.setcursor = exports.setcur = function(pos) {
    return cursor = pos;
  };

}).call(this);

/*
//@ sourceMappingURL=peasy.map
*/
