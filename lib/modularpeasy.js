// Generated by CoffeeScript 1.6.2
(function() {
  var hasOwnProperty, isMatcher, memo, parse, recursive, setMemoTag, setMemorizeRules,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  hasOwnProperty = Object.hasOwnProperty;

  isMatcher = function(item) {
    return typeof item === "function";
  };

  exports.setupGrammar = function(info, rules) {
    var memorizeSymbols, originalRules, recursiveSymbols, symbol, _i, _j, _len, _len1;

    rules.parseCache = {};
    rules.__parsingSymbols = {};
    if (rules.__originalRules) {
      return rules;
    }
    originalRules = rules.__originalRules = {};
    recursiveSymbols = rules.__leftRecursives;
    if (recursiveSymbols) {
      for (_i = 0, _len = recursiveSymbols.length; _i < _len; _i++) {
        symbol = recursiveSymbols[_i];
        originalRules[symbol] = rules[symbol];
        rules[symbol] = recursive(info, rules, symbol);
      }
    }
    memorizeSymbols = rules.__memorizeSymbols;
    if (memorizeSymbols) {
      for (_j = 0, _len1 = memorizeSymbols.length; _j < _len1; _j++) {
        symbol = memorizeSymbols[_j];
        originalRules[symbol] = rules[symbol];
        rules[symbol] = memorize(info, rules, symbol);
      }
    }
    return rules;
  };

  recursive = function(info, rules, symbol) {
    var rule;

    rule = rules.__originalRules[symbol];
    return function(start) {
      var callPath, hash, m, result, _base, _ref;

      hash = symbol + start;
      callPath = (_ref = (_base = rules.__parsingSymbols)[start]) != null ? _ref : _base[start] = [];
      if (__indexOf.call(callPath, symbol) < 0) {
        callPath.push(symbol);
        m = rules.parseCache[hash] = [void 0, -1];
        while (1) {
          result = rule(start);
          if (m[1] === info.cursor) {
            m[0] = result;
            break;
          } else {
            m[0] = result;
            m[1] = info.cursor;
          }
        }
        callPath.pop();
        return result;
      } else {
        m = rules.parseCache[hash];
        if (m[1] >= 0) {
          info.cursor = m[1];
          return m[0];
        } else {
          info.cursor = start;
          return m[0];
        }
      }
    };
  };

  setMemorizeRules = function(info, rules) {
    var memorizedSymbols, symbol, _i, _len, _results;

    memorizedSymbols = rules.memorizedSymbols;
    if (!memorizedSymbols) {
      return;
    }
    _results = [];
    for (_i = 0, _len = memorizedSymbols.length; _i < _len; _i++) {
      symbol = memorizedSymbols[_i];
      rules.__originalRules[symbol] = rules[symbol];
      _results.push(rules[symbol] = memorize(info, rules, symbol));
    }
    return _results;
  };

  exports.memorize = function(info, rules, symbol) {
    var parseCache, rule, tag;

    tag = rules.symbolToTagMap[symbol];
    rule = rules.__originalRules[symbol];
    parseCache = rules.parseCache;
    return function(start) {
      var hash, m, result;

      hash = tag + start;
      m = parseCache[hash];
      if (m) {
        info.cursor = m[1];
        return m[0];
      } else {
        result = rule(start);
        parseCache[hash] = [result, info.cursor];
        return result;
      }
    };
  };

  memo = function(info, rules, symbol) {
    var parseCache, tag;

    tag = rules.symbolToTagMap[symbol];
    parseCache = rules.parseCache;
    return function(start) {
      var hash, m;

      hash = tag + start;
      m = parseCache[hash];
      if (m) {
        info.cursor = m[1];
        return m[0];
      }
    };
  };

  setMemoTag = function(rules, symbol) {
    var i, tag;

    i = 1;
    while (1) {
      if (hasOwnProperty.call(rules.tags, symbol.slice(0, i))) {
        i++;
      } else {
        break;
      }
    }
    tag = symbol.slice(0, i);
    rules.symbolToTagMap[symbol] = tag;
    return rules.tags[tag] = true;
  };

  exports.andp = function() {
    var info, item, items;

    info = arguments[0], items = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    items = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!isMatcher(item)) {
          _results.push(literal(info, item));
        } else {
          _results.push(item);
        }
      }
      return _results;
    })();
    return function(start) {
      var result, _i, _len;

      info.cursor = start;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!(result = item(info.cursor))) {
          return;
        }
      }
      return result;
    };
  };

  exports.orp = function() {
    var info, item, items;

    info = arguments[0], items = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    items = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (!isMatcher(item)) {
          _results.push(literal(infor, item));
        } else {
          _results.push(item);
        }
      }
      return _results;
    })();
    return function(start) {
      var result, _i, _len;

      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        info.cursor = start;
        if (result = item(start)) {
          return result;
        }
      }
      return result;
    };
  };

  exports.notp = function(info, item) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      return !item(start);
    };
  };

  exports.any = function(info, item) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      var result, x;

      result = [];
      info.cursor = start;
      while ((x = item(info.cursor))) {
        result.push(x);
      }
      return result;
    };
  };

  exports.some = function(info, item) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      var result, x;

      result = [];
      info.cursor = start;
      if (!(x = item(info.cursor))) {
        return x;
      }
      while (1) {
        result.push(x);
        x = item(info.cursor);
        if (!x) {
          break;
        }
      }
      return result;
    };
  };

  exports.may = function(info, item) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      var x;

      info.cursor = start;
      if (x = item(info.cursor)) {
        return x;
      } else {
        info.cursor = start;
        return true;
      }
    };
  };

  exports.follow = function(info, item) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      var x;

      info.cursor = start;
      if (x = item(info.cursor)) {
        info.cursor = start;
        return x;
      }
    };
  };

  exports.times = function(info, item, n) {
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    return function(start) {
      var i, x;

      info.cursor = start;
      i = 0;
      while (i++ < n) {
        if (x = item(info.cursor)) {
          result.push(x);
        } else {
          return;
        }
      }
      return result;
    };
  };

  exports.seperatedList = function(info, item, separator) {
    if (separator == null) {
      separator = spaces;
    }
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    if (!isMatcher(separator)) {
      separator = literal(separator);
    }
    return function(start) {
      var result, x;

      info.cursor = start;
      result = [];
      x = item(info.cursor);
      if (!x) {
        return;
      }
      while (1) {
        result.push(x);
        if (!(x = item(info.cursor))) {
          break;
        }
      }
      return result;
    };
  };

  exports.timesSeperatedList = function(info, item, n, separator) {
    if (separator == null) {
      separator = spaces;
    }
    if (!isMatcher(item)) {
      item = literal(info, item);
    }
    if (!isMatcher(separator)) {
      separator = literal(separator);
    }
    return function(start) {
      var i, result, x;

      info.cursor = start;
      result = [];
      x = item(info.cursor);
      if (!x) {
        return;
      }
      i = 1;
      while (i++ < n) {
        result.push(x);
        if (!(x = item(info.cursor))) {
          break;
        }
      }
      return result;
    };
  };

  exports.literal = function(info, string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (info.data.slice(start, stop = start + len) === string) {
        info.cursor = stop;
        return true;
      }
    };
  };

  exports.literal_ = function(info, string) {
    return function(start) {
      var len, stop;

      len = string.length;
      if (info.data.slice(info.cursor, stop = info.cursor + len) === string) {
        info.cursor = stop;
        return true;
      }
    };
  };

  exports.char = function(info, c) {
    return function(start) {
      if (info.data[start] === c) {
        info.cursor = start + 1;
        return c;
      }
    };
  };

  exports.char_ = function(info, c) {
    return function() {
      if (info.data[info.cursor] === c) {
        info.cursor++;
        return c;
      }
    };
  };

  exports.spaces = function(info) {
    return function(start) {
      var len;

      len = 0;
      info.cursor = start;
      while (1) {
        switch (info.data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };
  };

  exports.spaces_ = function(info) {
    return function() {
      var len;

      len = 0;
      while (1) {
        switch (info.data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      return len;
    };
  };

  exports.spaces1 = function(info) {
    return function(start) {
      var len;

      len = 0;
      info.cursor = start;
      while (1) {
        switch (info.data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return info.cursor = info.cursor;
        return len;
      }
    };
  };

  exports.spaces1_ = function(info) {
    return function() {
      var len;

      len = 0;
      info.cursor = start;
      while (1) {
        switch (info.data[info.cursor++]) {
          case ' ':
            len++;
            break;
          case '\t':
            len += tabWidth;
            break;
          default:
            break;
        }
      }
      if (len) {
        return info.cursor = info.cursor;
        return len;
      }
    };
  };

  exports.wrap = function(info) {
    return function(item, left, right) {
      if (left == null) {
        left = spaces;
      }
      if (right == null) {
        right = spaces;
      }
      if (!isMatcher(item)) {
        item = literal(info, item);
      }
      return function(start) {
        var result;

        if (left(start) && (result = item(info.cursor) && right(info.cursor))) {
          return result;
        }
      };
    };
  };

  exports.identifierLetter = function(info) {
    return function(start) {
      var c;

      start = info.cursor;
      c = info.data[info.cursor];
      if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        info.cursor++;
        return true;
      }
    };
  };

  exports.identifierLetter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
        info.cursor++;
        return true;
      }
    };
  };

  exports.followIdentifierLetter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      return c === '$' || c === '_' || ('a' <= c && c < 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9');
    };
  };

  exports.digit = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('0' <= c && c <= '9')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.digit_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('0' <= c && c <= '9')) {
        return info.cursor++;
      }
    };
  };

  exports.letter = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.letter_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        return info.cursor++;
      }
    };
  };

  exports.lower = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('a' <= c && c <= 'z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.lower_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z')) {
        return info.cursor++;
      }
    };
  };

  exports.upper = function(info) {
    return function(start) {
      var c;

      c = info.data[start];
      if (('A' <= c && c <= 'Z')) {
        return info.cursor = start + 1;
      }
    };
  };

  exports.upper_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('A' <= c && c <= 'Z')) {
        return info.cursor++;
      }
    };
  };

  exports.identifier = function(info) {
    return function(start) {
      var c;

      info.cursor = start;
      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
        info.cursor++;
      } else {
        return;
      }
      while (1) {
        c = info.data[info.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
          info.cursor++;
        } else {
          break;
        }
      }
      return true;
    };
  };

  exports.identifier_ = function(info) {
    return function() {
      var c;

      c = info.data[info.cursor];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || 'c' === '$' || 'c' === '_') {
        info.cursor++;
      } else {
        return;
      }
      while (1) {
        c = info.data[info.cursor];
        if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_') {
          info.cursor++;
        } else {
          break;
        }
      }
      return true;
    };
  };

  exports.isdigit = function(c) {
    return ('0' <= c && c <= '9');
  };

  exports.isletter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
  };

  exports.islower = function(c) {
    return ('a' <= c && c <= 'z');
  };

  exports.isupper = function(c) {
    return ('A' <= c && c <= 'Z');
  };

  exports.isIdentifierLetter = function(c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || 'c' === '$' || 'c' === '_';
  };

  parse = function(text) {
    var grammar, makeGrammar;

    makeGrammar = function(info) {
      var a, b, rules, x;

      a = char(info, 'a');
      b = char(info, 'b');
      x = char(info, 'x');
      rules = {
        A: function(start) {
          var m;

          return (m = rules.B(start)) && x(info.cursor) && m + 'x' || m || a(start);
        },
        B: function(start) {
          return rules.C(start);
        },
        C: function(start) {
          return rules.A(start) || b(start);
        }
      };
      return recursiveGrammar(info, rules);
    };
    grammar = makeGrammar({
      data: text,
      cursor: 0
    });
    return grammar.A(0);
  };

}).call(this);

/*
//@ sourceMappingURL=modularpeasy.map
*/
