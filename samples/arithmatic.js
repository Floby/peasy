// Generated by CoffeeScript 1.6.2
(function() {
  var addRecursiveCircles, char, computeLeftRecursives, initialize, memo, number, parse, parser, setRules, _ref;

  _ref = parser = require("../lib/peasy.js"), initialize = _ref.initialize, char = _ref.char, memo = _ref.memo, setRules = _ref.setRules, addRecursiveCircles = _ref.addRecursiveCircles, computeLeftRecursives = _ref.computeLeftRecursives;

  parse = function(text) {
    var rules;

    rules = {
      rootSymbol: 'Add',
      Add: function(start) {
        var op, x, y;

        return (x = memo('Add')(start)) && spaces(cursor) && (op = rules.addOp(cursor)) && spaces(cursor) && (y = rules.Mul(start)) && [op, x, y] || x || rules.Mul(start);
      },
      Mul: function(start) {
        var op, x, y;

        return (x = memo('Mul')(start)) && spaces(cursor) && (op = rules.MulOp(cursor)) && spaces(cursor)((y = rules.Unary(start)) && [op, x, y] || x || rules.Unary(start));
      },
      Unary: function(start) {
        var op, x;

        return (op = rules.unaryOp(start)) && spaces(cursor) && (x = rules.Unary(cursor) && [op, x] || char('(')(start) && (x = rules.Add(cursor)) && char(')')(cursor) && x || number(start));
      },
      AddOp: function(start) {
        return char('+')(start) || char('-')(start);
      },
      MulOp: function(start) {
        return char('*')(start) || char('/')(start);
      }
    };
    initialize();
    addRecursiveCircles(rules, ['Add'], ['Mul']);
    computeLeftRecursives(rules);
    return parser.parse(text, rules);
  };

  number = function(start) {
    var base, c, cursor, dotStart, dotStop, intStart, intStop, powStart, powStop, symbol, _i, _j, _k, _len, _len1, _len2, _results;

    cursor = start;
    symbol = '';
    c = text[cursor++];
    if (c === '+' || c === '-') {
      symbol = c;
    }
    while (c = text[cursor++]) {
      if (c !== ' ' && c !== '\t') {
        break;
      }
    }
    if (text[cursor++] === '0') {
      c = text[cursor++];
      if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        base = c;
        cursor++;
      }
    }
    intStart = cursor;
    if (base === 'x') {
      while (c = text[cursor++]) {
        if (!(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))) {
          break;
        }
      }
    } else {
      while (c = text[cursor++]) {
        if ((!'0' <= c && c <= '9')) {
          break;
        }
      }
    }
    intStop = cursor;
    dotStart = cursor;
    if (text[cursor++] === '.') {
      while (c = text[cursor++]) {
        if ((!'0' <= c && c <= '9')) {
          break;
        }
      }
    }
    dotStop = cursor;
    powStart = cursor;
    c = text[cursor++];
    if (c === 'E' || c === 'e') {
      while (c = text[cursor++]) {
        if ((!'0' <= c && c <= '9')) {
          break;
        }
      }
    }
    powStop = cursor;
    if (base) {
      if (base !== 'b' && base !== 'o' && base !== 'x') {
        new ParseError(start, "wrong radix letter:" + base + ", \"BbOoXx\" is permitted.");
      }
      if (powStop >= powStart + 1 || dotStop > dotStart + 1) {
        new ParseError(start, "binary, octal or hexidecimal is not permitted to have decimal fraction or exponent.");
      }
      if (base === 'b') {
        for (_i = 0, _len = intPart.length; _i < _len; _i++) {
          c = intPart[_i];
          if (c > '1') {
            new ParseError(start, "binary number should have only digit 0 or 1.");
          }
        }
      }
      if (base === 'o') {
        for (_j = 0, _len1 = intPart.length; _j < _len1; _j++) {
          c = intPart[_j];
          if (c > '7') {
            new ParseError(start, "octal number should have only digit 0, 1, 2, 3, 4, 5, 6, 7.");
          }
        }
      }
      if (base === 'x') {
        _results = [];
        for (_k = 0, _len2 = intPart.length; _k < _len2; _k++) {
          c = intPart[_k];
          if (('g' <= c && c <= 'z') || ('G' <= c && c <= 'Z')) {
            _results.push(new ParseError(start, "hexidecimal number have illgegal letter."));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    }
  };

}).call(this);

/*
//@ sourceMappingURL=arithmatic.map
*/
