<!DOCTYPE html>
<!-- saved from url=(0047)file:///C:/Users/ccc/appdata/local/temp/85.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style>body
{
  font-size:15px;
  line-height:1.7;
  overflow-x:hidden;

    background-color: white;
    border-radius: 3px;
    border: 3px solid #EEE;
    box-shadow: inset 0 0 0 1px #CECECE;
    font-family: Helvetica, arial, freesans, clean, sans-serif;
    width: 912px;
    padding: 30px;
    margin: 2em auto;

    color:#333333;
}


.body-classic{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:16px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

body>:first-child
{
  margin-top:0!important;
}

body>:last-child
{
  margin-bottom:0!important;
}

blockquote,dl,ol,p,pre,table,ul {
  border: 0;
  margin: 15px 0;
  padding: 0;
}

body a {
  color: #4183c4;
  text-decoration: none;
}

body a:hover {
  text-decoration: underline;
}

body a.absent
{
  color:#c00;
}

body a.anchor
{
  display:block;
  padding-left:30px;
  margin-left:-30px;
  cursor:pointer;
  position:absolute;
  top:0;
  left:0;
  bottom:0
}

/*h4,h5,h6{ font-weight: bold; }*/

.octicon{
  font:normal normal 16px sans-serif;
  width: 1em;
  height: 1em;
  line-height:1;
  display:inline-block;
  text-decoration:none;
  -webkit-font-smoothing:antialiased
}

.octicon-link {
  background: url("data:image/svg+xml;utf8,<?xml version='1.0' standalone='no'?> <!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'> <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1024 832'> <metadata>Copyright (C) 2013 by GitHub</metadata> <!-- scale(0.01565557729941) --> <path transform='' d='M768 64h-192s-254 0-256 256c0 22 3 43 8 64h137c-11-19-18-41-18-64 0-128 128-128 128-128h192s128 0 128 128-128 128-128 128 0 64-64 128h64s256 0 256-256-256-256-256-256z m-72 192h-137c11 19 18 41 18 64 0 128-128 128-128 128h-192s-128 0-128-128 128-128 128-128-4-65 66-128h-66s-256 0-256 256 256 256 256 256h192s256 0 256-256c0-22-4-44-8-64z'/> </svg>");
  background-size: contain;
  background-repeat: no-repeat;
  background-position: bottom;
}

.octicon-link:before{
  content:'\a0';
}

body h1,body h2,body h3,body h4,body h5,body h6{
  margin:1em 0 15px;
  padding:0;
  font-weight:bold;
  line-height:1.7;
  cursor:text;
  position:relative
}

body h1 .octicon-link,body h2 .octicon-link,body h3 .octicon-link,body h4 .octicon-link,body h5 .octicon-link,body h6 .octicon-link{
  display:none;
  color:#000
}

body h1:hover a.anchor,body h2:hover a.anchor,body h3:hover a.anchor,body h4:hover a.anchor,body h5:hover a.anchor,body h6:hover a.anchor{
  text-decoration:none;
  line-height:1;
  padding-left:0;
  margin-left:-22px;
  top:15%
}

body h1:hover a.anchor .octicon-link,body h2:hover a.anchor .octicon-link,body h3:hover a.anchor .octicon-link,body h4:hover a.anchor .octicon-link,body h5:hover a.anchor .octicon-link,body h6:hover a.anchor .octicon-link{
  display:inline-block
}

body h1 tt,body h1 code,body h2 tt,body h2 code,body h3 tt,body h3 code,body h4 tt,body h4 code,body h5 tt,body h5 code,body h6 tt,body h6 code{
  font-size:inherit
}

body h1{
  font-size:2.5em;
  border-bottom:1px solid #ddd
}

body h2{
  font-size:2em;
  border-bottom:1px solid #eee
}

body h3{
  font-size:1.5em
}

body h4{
  font-size:1.2em
}

body h5{
  font-size:1em
}

body h6{
  color:#777;
  font-size:1em
}

body p,body blockquote,body ul,body ol,body dl,body table,body pre{
  margin:15px 0
}

body h1 tt,body h1 code,body h2 tt,body h2 code,body h3 tt,body h3 code,body h4 tt,body h4 code,body h5 tt,body h5 code,body h6 tt,body h6 code
{
  font-size:inherit;
}


body hr
{
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC);
  background-repeat: repeat-x;
  /*background:transparent url(http://overblown.net/files/markdown/dirty-shade.png) repeat-x 0 0;*/
  background-color: transparent;
  background-position: 0;
  border:0 none;
  color:#ccc;
  height:4px;
  margin:15px 0;
  padding:0;
}

body li p.first
{
  display:inline-block;
}

body ul,body ol
{
  padding-left:30px;
}

body ul.no-list,body ol.no-list
{
  list-style-type:none;
  padding:0;
}

body ul ul,body ul ol,body ol ol,body ol ul
{
  margin-bottom:0;
  margin-top:0;
}

body dl
{
  padding:0;
}

body dl dt
{
  font-size:14px;
  font-style:italic;
  font-weight:700;
  margin-top:15px;
  padding:0;
}

body dl dd
{
  margin-bottom:15px;
  padding:0 15px;
}

body blockquote
{
  border-left:4px solid #DDD;
  color:#777;
  padding:0 15px;
}

body blockquote>:first-child
{
  margin-top:0;
}

body blockquote>:last-child
{
  margin-bottom:0;
}

body table
{
  display:block;
  overflow:auto;
  width:100%;
}

body table th
{
  font-weight:700;
}

body table th,body table td
{
  border:1px solid #ddd;
  padding:6px 13px;
}

body table tr
{
  background-color:#fff;
  border-top:1px solid #ccc;
}

body table tr:nth-child(2n)
{
  background-color:#f8f8f8;
}

body img
{
  -moz-box-sizing:border-box;
  box-sizing:border-box;
  max-width:100%;
}

body span.frame
{
  display:block;
  overflow:hidden;
}

body span.frame>span
{
  border:1px solid #ddd;
  display:block;
  float:left;
  margin:13px 0 0;
  overflow:hidden;
  padding:7px;
  width:auto;
}

body span.frame span img
{
  display:block;
  float:left;
}

body span.frame span span
{
  clear:both;
  color:#333;
  display:block;
  padding:5px 0 0;
}

body span.align-center
{
  clear:both;
  display:block;
  overflow:hidden;
}

body span.align-center>span
{
  display:block;
  margin:13px auto 0;
  overflow:hidden;
  text-align:center;
}

body span.align-center span img
{
  margin:0 auto;
  text-align:center;
}

body span.align-right
{
  clear:both;
  display:block;
  overflow:hidden;
}

body span.align-right>span
{
  display:block;
  margin:13px 0 0;
  overflow:hidden;
  text-align:right;
}

body span.align-right span img
{
  margin:0;
  text-align:right;
}

body span.float-left
{
  display:block;
  float:left;
  margin-right:13px;
  overflow:hidden;
}

body span.float-left span
{
  margin:13px 0 0;
}

body span.float-right
{
  display:block;
  float:right;
  margin-left:13px;
  overflow:hidden;
}

body span.float-right>span
{
  display:block;
  margin:13px auto 0;
  overflow:hidden;
  text-align:right;
}

body code,body tt
{
  background-color:#f8f8f8;
  border:1px solid #ddd;
  border-radius:3px;
  margin:0 2px;
  padding:0 5px;
}

body code
{
  white-space:nowrap;
}


code,pre{
  font-family:Consolas, "Liberation Mono", Courier, monospace;
  font-size:12px
}

body pre>code
{
  background:transparent;
  border:none;
  margin:0;
  padding:0;
  white-space:pre;
}

body .highlight pre,body pre
{
  background-color:#f8f8f8;
  border:1px solid #ddd;
  font-size:13px;
  line-height:19px;
  overflow:auto;
  padding:6px 10px;
  border-radius:3px
}

body pre code,body pre tt
{
  background-color:transparent;
  border:none;
  margin:0;
  padding:0;
}

body .task-list{
  list-style-type:none;
  padding-left:10px
}

.task-list-item{
  padding-left:20px
}

.task-list-item label{
  font-weight:normal
}

.task-list-item.enabled label{
  cursor:pointer
}

.task-list-item+.task-list-item{
  margin-top:5px
}

.task-list-item-checkbox{
  float:left;
  margin-left:-20px;
  margin-top:7px
}


.highlight{
  background:#ffffff
}

.highlight .c{
  color:#999988;
  font-style:italic
}

.highlight .err{
  color:#a61717;
  background-color:#e3d2d2
}

.highlight .k{
  font-weight:bold
}

.highlight .o{
  font-weight:bold
}

.highlight .cm{
  color:#999988;
  font-style:italic
}

.highlight .cp{
  color:#999999;
  font-weight:bold
}

.highlight .c1{
  color:#999988;
  font-style:italic
}

.highlight .cs{
  color:#999999;
  font-weight:bold;
  font-style:italic
}

.highlight .gd{
  color:#000000;
  background-color:#ffdddd
}

.highlight .gd .x{
  color:#000000;
  background-color:#ffaaaa
}

.highlight .ge{
  font-style:italic
}

.highlight .gr{
  color:#aa0000
}

.highlight .gh{
  color:#999999
}

.highlight .gi{
  color:#000000;
  background-color:#ddffdd
}

.highlight .gi .x{
  color:#000000;
  background-color:#aaffaa
}

.highlight .go{
  color:#888888
}

.highlight .gp{
  color:#555555
}

.highlight .gs{
  font-weight:bold
}

.highlight .gu{
  color:#800080;
  font-weight:bold
}

.highlight .gt{
  color:#aa0000
}

.highlight .kc{
  font-weight:bold
}

.highlight .kd{
  font-weight:bold
}

.highlight .kn{
  font-weight:bold
}

.highlight .kp{
  font-weight:bold
}

.highlight .kr{
  font-weight:bold
}

.highlight .kt{
  color:#445588;
  font-weight:bold
}

.highlight .m{
  color:#009999
}

.highlight .s{
  color:#d14
}

.highlight .n{
  color:#333333
}

.highlight .na{
  color:#008080
}

.highlight .nb{
  color:#0086B3
}

.highlight .nc{
  color:#445588;
  font-weight:bold
}

.highlight .no{
  color:#008080
}

.highlight .ni{
  color:#800080
}

.highlight .ne{
  color:#990000;
  font-weight:bold
}

.highlight .nf{
  color:#990000;
  font-weight:bold
}

.highlight .nn{
  color:#555555
}

.highlight .nt{
  color:#000080
}

.highlight .nv{
  color:#008080
}

.highlight .ow{
  font-weight:bold
}

.highlight .w{
  color:#bbbbbb
}

.highlight .mf{
  color:#009999
}

.highlight .mh{
  color:#009999
}

.highlight .mi{
  color:#009999
}

.highlight .mo{
  color:#009999
}

.highlight .sb{
  color:#d14
}

.highlight .sc{
  color:#d14
}

.highlight .sd{
  color:#d14
}

.highlight .s2{
  color:#d14
}

.highlight .se{
  color:#d14
}

.highlight .sh{
  color:#d14
}

.highlight .si{
  color:#d14
}

.highlight .sx{
  color:#d14
}

.highlight .sr{
  color:#009926
}

.highlight .s1{
  color:#d14
}

.highlight .ss{
  color:#990073
}

.highlight .bp{
  color:#999999
}

.highlight .vc{
  color:#008080
}

.highlight .vg{
  color:#008080
}

.highlight .vi{
  color:#008080
}

.highlight .il{
  color:#009999
}

.highlight .gc{
  color:#999;
  background-color:#EAF2F5
}

.type-csharp .highlight .k{
  color:#0000FF
}

.type-csharp .highlight .kt{
  color:#0000FF
}

.type-csharp .highlight .nf{
  color:#000000;
  font-weight:normal
}

.type-csharp .highlight .nc{
  color:#2B91AF
}

.type-csharp .highlight .nn{
  color:#000000
}

.type-csharp .highlight .s{
  color:#A31515
}

.type-csharp .highlight .sc{
  color:#A31515
}</style><title>readme[cn]</title></head><body><h1>
<a name="peasy-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%80%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#peasy-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%80%8C%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="octicon octicon-link"></span></a>Peasy ：一个简单而强大的解析器</h1>

<h3>
<a name="parsing-is-easy" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#parsing-is-easy"><span class="octicon octicon-link"></span></a>Parsing is easy！</h3>

<p>有编写解析器的经历吗？有了Peasy ，再也不需要象以前那样玩高难的<a href="https://raw.github.com/chaosim/peasy/master/doc/ballacrobatics.jpg">抛球杂技</a>了，
现在只需要<a href="https://raw.github.com/chaosim/peasy/master/doc/dolphinball.jpg">象这样</a>就能把它轻松搞定:)</p>

<h3>
<a name="%E7%94%A8%E6%B3%95" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E7%94%A8%E6%B3%95"><span class="octicon octicon-link"></span></a><strong>用法</strong>
</h3>

<p><strong>客户端浏览器</strong>:
复制twoside.js, peasy.js, logicpeasy.js（如果需要逻辑功能)到项目文件夹，按次序添加到yourpage.html的<code>&lt;script&gt;</code>标签。</p>

<p><strong>node.js</strong>:
除了直接从github复制文件以外，node下也可以通过npm安装：<code>npm install peasy</code></p>

<p><strong>twoside</strong>:
twoside是我编写的一个小工具，使模块可以同时用于浏览器和node.js。如果不想使用它，直接忽略并删除peasy.js和logicpeasy.js前两行，并删除代码中的exports变量及其引用。
关于twoside的详细信息，请参阅https://github/chaosim/twoside。在无需考虑客户端浏览器的纯node环境下，可以忽略twoside，不影响使用。可以通过npm安装twoside：<code>npm install twoside</code></p>

<h3>
<a name="%E4%BB%8B%E7%BB%8D" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E4%BB%8B%E7%BB%8D"><span class="octicon octicon-link"></span></a>介绍</h3>

<p>peasy从概念到实现以及使用都极其简单。peasy只包含一个类Parser，该类除了启动解析的parse成员函数以外，只包含两类成员函数，一类叫匹配函数，不带参数，其作用是直接检测被解析数据(data)和调整解析指针(cur)，包括eoi, spaces, spaces1, digit, letter, upper, lower, number, string, identifier, identifierLetter, followIdentifierLetter等。另一类叫组合函数，产生匹配函数作为结果，包括rec, memo, orp, andp, notp, may, any, some, times, list, listn, follow, literal, char, wrap等。其中rec实现左递归功能，使得peasy具有最强的语法表达能力；memo实现缓存功能，尽可能将解析过程保持在最低的时间复杂度上。</p>

<p>logicpeasy 是对peasy的扩展，它使得解析规则可以用逻辑变量作为参数。</p>

<h3>
<a name="%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%A7%A3%E6%9E%90%E5%99%A8" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="octicon octicon-link"></span></a>开始编写解析器</h3>

<p>推荐如下方法：</p>

<p>新建模块（可以用samples下的某个文件作为模板），require peasy或logicpeasy，以peasy.Parser或logicpeasy.Parser作为基类，建立新Parser类。</p>

<p>建议编写代码以前，先阅读peasy本身的代码以及test和samples中的代码，这些代码都是简单自明的，读过之后您就能直接进入状态了。</p>

<p>为了让大家马上对用peasy编写解析器有个直观感觉，下面列出了samples/arithmatic.coffee的主体内容。为节省篇幅和便于阅读，代码中用...省略了不影响整体结构的段落。</p>

<pre><code>  exports.Parser = class Parser extends peasy.Parser
    constructor: -&gt;
      super # call the constructor of peasy.Parser
      self = @  save 'this' to self in advance, avoid the problem that 'this' may be bound to wrong object.

      number = -&gt; ...
      string = -&gt; ...

      {orp, list, rec, memo, wrap, char, literal, spaces, eoi, identifier} = self

      question = char('?'); colon = char(':'); comma = char(','); dot = char('.')
      lpar = char('('); rpar = char(')')
      lbracket = char('['); rbracket = char(']')

      myop = (op) -&gt;
        if op.length==1 then opFn = char(op) else opFn = literal(op)
        if _in_(op[0], identifierCharSet)
          -&gt; spaces() and (op=opFn()) and spaces() and not _in_(data[self.cur], identifierCharSet) and ' '+op+' '
        else -&gt; spaces() and (op=opFn()) and spaces() and op

      posNeg = (op) -&gt; ...
      positive = posNeg('+'); negative = posNeg('-')
      ...
      assign = myop('='); ..., bitorassign = myop('|=')

      error = (msg) -&gt; throw self.data[self.cur-20..self.cur+20]+' '+self.cur+': '+msg
      expect = (fn, msg) -&gt; fn() or error(msg)

      incDec = orp(inc, dec)
      prefixExpr = -&gt; (op=incDec()) and (x=headExpr()) and op+x
      suffixExpr = -&gt; (x=headExpr()) and (op=incDec()) and x+op

      paren = (item, left=lpar, right=rpar, msg='expect ) to match (') -&gt;
        -&gt; start=self.cur; left() and (x=item()) and expect(right, msg+' at: '+start) and x

      paren1 = paren(-&gt; (spaces() and (x=expression()) and spaces() and x))
      parenExpr = memo -&gt; (x=paren1()) and '('+x+')'
      atom = memo orp(parenExpr, number, string, identifier)
      newExpr = -&gt; new_() and (x=callProp()) and 'new '+x
      unaryTail = orp(prefixExpr, suffixExpr, atom)
      unaryExpr = -&gt; (op=unaryOp()) and (x=unaryTail()) and op+x

      bracketExpr1 = wrap(paren(wrap(-&gt; commaExpr()), lbracket, rbracket, 'expect ) to match ('))
      bracketExpr = -&gt; (x=bracketExpr1()) and '['+x+']'
      wrapDot = wrap(dot)
      dotIdentifier = -&gt; wrapDot() and (id=expect(identifier, 'expect identifier')) and '.'+id
      attr = orp(bracketExpr, dotIdentifier)
      param = paren -&gt; (spaces() and (x=expression()) and spaces() and expect(rpar,'expect )')) or ' '
      paramExpr = memo -&gt; (x=param()) and '('+x+')'
      callPropTail = orp(paramExpr, attr)
      callPropExpr = rec -&gt; (h=headExpr()) and (((e=callPropTail()) and h+e) or h)
      property = rec -&gt; (h=headExpr()) and (((e=attr()) and h+e) or h)
      headAtom = memo orp(parenExpr, identifier)
      headExpr = memo orp(callPropExpr, headAtom)
      simpleExpr = memo orp(unaryExpr, prefixExpr, suffixExpr, callPropExpr, newExpr, atom)

      binaryOpPriorityMap = { 5: ['*', '/', '//', '%'], ...}

      binaryOpItems = []
      do -&gt; for k, ops of binaryOpPriorityMap
        for op in ops then binaryOpItems.push [op, {text:op, pri:parseInt(k)}]

      binarysm = new StateMachine(binaryOpItems)

      binaryOperator = memo -&gt;
        m = binarysm.match(self.data, self.cur)
        if m[0] then self.cur = m[1]; m[0]

      expr = (n) -&gt; binary = rec -&gt;
          if x = binary()
            beforeOp = self.cur
            if (op=binaryOperator()) and (n&gt;=op.pri&gt;=x.pri) and (fn=expr(op.pri)) and y=fn()
              {text: x.text+op.text+y.text, pri:op.pri}
            else self.cur = beforeOp; x
          else if x=simpleExpr() then {text:x, pri:4}

      orBinary = expr(15)
      logicOrExpr = -&gt; (x = orBinary()) and x.text
      wrapQuestion = wrap(question); wrapColon = wrap(colon)
      condition = -&gt; (x=logicOrExpr()) and ((wrapQuestion() and (y=assignExpr()) and expect(wrapColon, 'expect :') and (z=assignExpr()) and x+'? '+y+': '+z) or x)      
      assignOperator = orp(assign, addassign, ..., bitorassign)
      assignExpr_ = -&gt; if (v=property()) and (op=assignOperator()) then (e = expect(assignExpr, 'expect the right hand side of assign.')) and v+op+e
      assignExpr = orp(assignExpr_, condition)
      expression_ = list(assignExpr, wrap(comma))
      expression = -&gt; x = expression_(); if x then x.join(',')

      @root = -&gt; (x=expression()) and expect(eoi, 'expect end of input') and x
</code></pre>

<p>在samples/arithmatic2.coffee中，全部代码只有180行，还包含了词法分析器的功能。能够完整地处理javascript这种复杂程度的表达式，而代码又如此简单，可以说只有peasy能够做到。</p>

<p>上述代码有几点独特之处需要解释一下：</p>

<ul>
<li>coffeescript的语法使得规则可读性非常好，不亚于其它任何编译器产生器的规则定义，javascript下则将稍逊一筹。</li>
<li>将所有规则在Parser类的constructor中设置为类的实例成员，而不是原型（prototype）成员，可以避免很多可能的与this绑定相关的问题。我曾经试过原型（prototype）成员的方案，测试和调试过程中发现有很多隐患。另外，避免查找prototype继承链，也能提高解析器的速度。</li>
<li>关于二元表达式的处理（expr(n)和它生成的binary = rec ...)也是peasy的独特之处。这将在下文中进一步解释。</li>
</ul><p>也可以从peasy.coffee(或js)或logicpeasy.coffee(或js)开始，直接在其中进行修改直到完成自己的解析器。</p>

<h3>
<a name="%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D"><span class="octicon octicon-link"></span></a>实例介绍</h3>

<p>项目中带有几个实例，解说一下：</p>

<p>dsl.coffee 是我在另一项目中利用peasy解析小语言的实例。</p>

<p>arimatic.coffee利用peasy对左递归的支持完成了javascript表达式的解析。它的特点是用一个函数生成所有优先级二元表达式的左递归规则。解析的时候从最低优先级的规则（逗号表达式）开始，调用栈经历所有优先级后得到最终结果。这种方法是线性时间的，但因为要经历很长的调用栈，对效率会有所影响。比如即使象1这样的表达式，也要变换成乘法式，加法式，...，逻辑或表达式，条件式，逗号式。</p>

<p>arithmatic2.coffee是避免了上述问题，可以根据运算符跨越式提升表达式优先级。比如 1 || 1，可以直接将1提升成或表达式的优先级。</p>

<p>这两个模块演示的算术表达式的解析方法都是独特的，我尚没有发现其它类似的实现。如果您发现有相近或更好的方法，请告诉我。</p>

<h3>
<a name="api" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#api"><span class="octicon octicon-link"></span></a>api</h3>

<h4>
<a name="class-parserpeasycoffeepeasyjs-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%9F%BA%E7%B1%BB" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#class-parserpeasycoffeepeasyjs-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%9F%BA%E7%B1%BB"><span class="octicon octicon-link"></span></a>class Parser(peasy.coffee/peasy.js): 解析器基类</h4>

<h5>
<a name="%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="octicon octicon-link"></span></a>数据成员</h5>

<p><code>data</code>：被解析数据，常见数据类型是文本，字符串。也可以用peasy解析二进制流，数组，列表，树等其他数据</p>

<p><code>cur</code>：解析指针，指向当前解析位置</p>

<p><code>ruleIndex</code>: 每一个rec和memo的匹配函数（rule参数）都对应唯一的一个ruleIndex</p>

<p><code>ruleStack</code>: 左递归规则(rec(rule))执行的时候需要查看ruleStack，请参看rec的代码</p>

<p><code>cache</code>: 保存左递归规则(rec(rule))和缓存规则(memo(rule))已经解析到的结果</p>

<h5>
<a name="%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="octicon octicon-link"></span></a>成员函数</h5>

<p>以下介绍peasy的组合函数和匹配函数。这里只列举最常用的几个，因为所有的函数都很简单，函数名都是自我解释性的，而且彼此平行，都可以根据需要使用、删除，修改。把它们包含在peasy中，主要起到示范的作用，如果需要用到，请参看实现代码。</p>

<p>以下说明中，成功指返回真值，包括非0数字，非空字符串，数组，对象等。失败指返回假值，包括undefined, null, 0, ''等。</p>

<p><code>parse(data, root=self.root, cur=0)</code>, 设置被解析数据data，起始匹配函数（默认为self.root）, 开始解析指针（默认为0）.</p>

<h5>
<a name="%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0"><span class="octicon octicon-link"></span></a>组合函数</h5>

<p><code>rec(rule)</code>, 将rule作为左递归规则处理。产生的结果函数将反复查看缓存，获取初始解析结果，并一直扩展到没有更多的结果为止。</p>

<p><code>memo(rule)</code>，产生的结果函数将查看并缓存rule在每一个位置的解析结果，避免重复解析。</p>

<p><code>orp(items...)</code>。产生的匹配函数依次从同一开始位置执行items中的项，当某一项解析成功则返回该项结果表示整体成功，所有项失败才失败。</p>

<p>orp可能是最常用到的组合函数。因为不能够写<code>item1() or item2() ... or itemn()</code>, 而必须写<code>start=self.cur; items() or ((self.cur=start) or item2()) ...  or ((self.cur=start) or itemn())</code>。如果忽视这一点，这将会成为代码中的一个陷阱。</p>

<p><code>andp(items...)</code>, 产生的匹配函数依次执行items中的项，每一次都从前一项的到达位置继续执行，当某一项解析失败则立即返回undefined并表示整体失败，所有项成功才成功并返回最后一项的结果。</p>

<p>andp在实际的代码中很少用到。因为可以写<code>item1() and item2() ... and itemn()</code>。 而且经常需要这样写：<code>(x=item1()) and (y=item2()) ... itemn() and doSomeProcess(x, y)</code></p>

<p><code>literal: literal(item)</code>, item是字符串。产生的匹配函数将判断以解析指针开始的字符串是否与item匹配。如果匹配则成功，否则失败。</p>

<p>出于方便，其它组合函数会根据需要将它们的字符串类型的参数x转换为literal(x)。请根据源码查看哪些函数用到了literal转换。</p>

<p><code>char(c)</code>, c是字符。产生的匹配函数将判断以解析指针开始的字符是否为c。如果匹配则成功，否则失败。</p>

<p><code>wrap(item, left=spaces, right=spaces)</code> 产生的匹配函数执行如下判断<code>if left() and result = item() and right() then result</code></p>

<h5>
<a name="%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0"><span class="octicon octicon-link"></span></a>匹配函数</h5>

<p><code>eoi</code>: 如果遇到数据结束(end of input), 则成功。</p>

<p><code>spaces</code>：0个或多个空格。总是成功，结果为（空格个数+1）。</p>

<p><code>spaces1</code>: 1个或多个空格。结果为空格个数。如果空格个数为0，则失败。</p>

<h4>
<a name="logicpeasy%E7%9A%84parser%E7%B1%BB" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#logicpeasy%E7%9A%84parser%E7%B1%BB"><span class="octicon octicon-link"></span></a>logicpeasy的Parser类</h4>

<p>类成员
<code>trail</code>：<code>self.trail = new Trail</code>, 保存了变量绑定踪迹。</p>

<h5>
<a name="%E9%9D%9E%E6%AD%A3%E8%A7%84%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E9%9D%9E%E6%AD%A3%E8%A7%84%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0"><span class="octicon octicon-link"></span></a>非正规匹配函数</h5>

<p><em>前面介绍的匹配函数是正规的匹配函数，可以作为象orp这样的组合函数的参数。非正规匹配函数和匹配函数类似，也直接操作解析数据和指针。但是因为带有参数，因而不能直接作为orp之类组合函数的参数，如果必要，可以转换为 <code>-&gt; fn(arg1, arg2, ...)</code>。</em></p>

<p><code>bind(vari, term)</code>: 绑定变量和项</p>

<p><code>unify(x, y, equal=((x, y) -&gt; x==y))</code>: 以equal作为相等函数，合一x和y</p>

<p><code>unifyList = (xs, ys, equal=((x, y) -&gt; x==y))</code>: 以equal作为相等函数，合一两个列表x和y</p>

<h5>
<a name="%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0-1" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0-1"><span class="octicon octicon-link"></span></a>组合函数</h5>

<p><code>unifyChar(x)</code>， <code>unifyDigit(x)</code>, <code>unifyLetter(x)</code>,  <code>unifyLower(x)</code>, <code>unifyUpper(x)</code>, <code>unifyIdentifier(x)</code>：这些函数与peasy中的类似名称的函数功能相近，所不同之处是参数x可以是逻辑变量。</p>

<p><code>orp(items...)</code>: 重载的orp扩展了与逻辑变量有关的trail处理。</p>

<h5>
<a name="%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%90%88%E4%B8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="octicon octicon-link"></span></a>逻辑变量与可以进行合一的数据类型</h5>

<p>Var，vars，Dummy, dummy用来构造逻辑变量。
UObject, uobject, UArray, uarray, Cons, cons, unifiable用来构造可以包含逻辑变量并合一的值。</p>

<h3>
<a name="030-%E6%96%B0%E5%8A%9F%E8%83%BD" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#030-%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="octicon octicon-link"></span></a>0.3.0 新功能</h3>

<ul>
<li>新的基于类的API</li>
<li>示例：arithmatic，arithmatic2，dsl</li>
<li>重写readme.md</li>
<li>新增readme[cn].md</li>
<li>grunt 工作流</li>
<li>重新组织文件夹，分离coffee和js文件夹。</li>
</ul><h3>
<a name="peasy%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%B1%E6%9D%A5" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#peasy%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="octicon octicon-link"></span></a>peasy项目的由来</h3>

<p>peasy项目是以本人的下一代编程语言项目dao(python)和daonode（coffeescript/javascript）的解析特性为基础移植而来的。dao项目实现了逻辑编程范式和函数编程范式的自然结合，是lisp和prolog语言的合体，并且内置包含了解析器功能。以逻辑变量作为参数编写文法规是dao项目的独创，这种逻辑参数文法具有强大的能力，具有超越传统编译原理所基于的乔姆斯基文法（包括上下文无关文法cfg、上下文相关文法csg以及0型文法）以及现在流行的解析表达式文法（peg)的表达能力（有兴趣的可以查阅编译原理中有关0-4型文法表达能力的一些论述，<a href="http://ccl.pku.edu.cn/doubtfire/Syntax/Introduction/Chomsky/Chomsky_Hierarchy/Chapter%2024%20The%20Chomsky%20Hierarchy.htm">比如这个链接</a>），同时无损于解析算法的时间复杂度。</p>

<h3>
<a name="python%E5%AE%9E%E7%8E%B0" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#python%E5%AE%9E%E7%8E%B0"><span class="octicon octicon-link"></span></a>python实现</h3>

<p>本项目有peasy的老版本python实现，因为时
间问题，api还是原来的，没有与coffee/js版本同步。</p>

<h3>
<a name="%E5%85%B3%E4%BA%8Epeasy%E7%9A%84%E5%85%B6%E5%AE%83%E4%BF%A1%E6%81%AF" class="anchor" href="file:///C:/Users/ccc/appdata/local/temp/85.html#%E5%85%B3%E4%BA%8Epeasy%E7%9A%84%E5%85%B6%E5%AE%83%E4%BF%A1%E6%81%AF"><span class="octicon octicon-link"></span></a>关于Peasy的其它信息</h3>

<p><strong>更多文档</strong>：<a href="http://chaosim.github.io/peasy/">http://chaosim.github.io/peasy/</a> 有更多关于peasy的文档。其中包含这个readme.md的中文版本。其它文档有的已经过时。</p>

<p><strong>项目站点</strong>：github <a href="https://github.com/chaosim/peasy">https://github.com/chaosim/peasy</a> 。</p>

<p><strong>测试</strong> ： Peasy使用karma/jasmine和mocha/chai进行测试框架，请看文件夹“/test”</p>

<p><strong>报告bug</strong> ：要报告或查找bug，请转到<a href="https://github.com/chaosim/peasy/issues">https://github.com/chaosim/peasy/issues</a> ，或电邮至simeon.chaos @ gmail.com</p>

<p><strong>开发平台</strong> ： Windows 7， node.js的0.10.0， CoffeeScript的1.6.3 。</p>

<p><strong>许可证(license)</strong> ：MIT，请看LICENSE</p></body></html>