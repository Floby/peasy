<!DOCTYPE html>

<html>
<head>
  <title>Peasy</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Peasy</h1>
<h6>Peasy means parsing is easy</h6>
<h6>an easy but powerful parser</h6>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>To use Peasy, just copy this file to your project, read it, modify it, write the grammar rules, and
remove any unnecessary stuffs in Peasy, and parse with the grammar.<br/>
See <a href="#peasysample">here</a> for a sample grammar in Peasy.<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>With Peasy, you write the parser by hand, just like to write any other kind of program.<br/>
You need not play many balls like that any more: <br/><br/>
<img src="https://raw.github.com/chaosim/peasy/master/doc/ballacrobatics.jpg" alt="ballacrobatics.jpg"><br/>
You just play one ball like so: <br/><br/>
<img src="https://raw.github.com/chaosim/peasy/master/doc/dolphinball.jpg" alt="dolphinball.jpg"><br/>,</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>You can embeded other features in the grammar rules seamless, such as lexer, rewriter, semantic action, error
process( error reporting, error recovering) or any other tasks; you can dynamicly modify the grammar rules, even
the parsed object, if you wish.<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Instead of a tool or a library, Peasy is rather a new method to write parser. As a demonstration, Peasy presents
itself as a module of single file, which includes some global variables used while parsing, some functions to
process left recursives symbols, some matchers which parse the text, and some cominators of matchers.<br/>  <br/></p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>With the method provided by Peasy, you can parse any object which is not only text, but also array, embedded list,
binary stream, or other data structures, like tree, graph, and so on.<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h6">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h6>Nothing but the method in Peasy is indispensable:<br/></h6>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <ul>
<li>If there is no left recursive symbol, you can remove the code about that(mainly three functions and 80 lines).<br/></li>
<li>If you don&#39;t need memorize the parsed result, you can remove the stuffs about
memorization(mainly refer to the function <code>memorize</code>).<br/></li>
<li>The matchers(e.g. spaces, literal, identifier, etc.) and combinators(e.g. andp, orp, etc) in this module exists just
for demostrating the method initiated by Peasy. You will see they are all very simple, after seeing them, I bet
that you would rather to remove them and write them by hand yourself when you write the grammar rules.<br/><br/></li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Peasy provided two method to tell which symbols are left recursive.<br/>
This module presents the semiautomatic method:<br/>
At first you write grammar rules in this manner: replace one and only one of
grmmar.symbol in the grammar rule with memo(symbol) for every left recursive circles. Before parsing, you first call
intialize(), and tell which symbol are left call or left recursive by calling  addParentChildrens(grammar, parentChildren)
and/or addRecursiveCircles(grammar, recursiveCircles...), and: call computeLeftRecursives(grammar), now
everything about left recursive symbols is computed and you can call parse(data, grammar, root) to do the work.</p>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>The notation <strong>@name</strong> in the comment below means a global variable, and <strong>$name</strong> means a parameter. <br/></p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4>global variables<br/></h4>
<p>It is for the performace reason that I use global variables, and at some time I will provide another version which
have the class Parser for people who prefer modularization to speed. Of course you can modify the code to have the
class Parser yourself if you like. It&#39;s just a snap to do that.</p>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>some global variable used while parsing<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>the text which is being parsed<br/>
<em>Don&#39;t be confused by the variable name, it could be not only text strings but also array, sequence, tree, graph,etc.</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> text</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>the length of @text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> textLength</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>the current position of parsing, use text[cursor] to get current character in parsed stream</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> cursor</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>the grammar object which contains all of rules defined for the symbol in grammar.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> grammar</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>saved the original rules of the grammar.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> originalRules</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>store the wrapped function to rule of the left recursive symbol with <code>recursive</code>, and before entering them, store it in grammar too.
when entering them, <code>grammar[symbol]</code> is unwrapped to <code>originalRules[symbol]</code> or <code>memorizeRecursives[symbol]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> recursiveRules
<span class="keyword">global</span> symbolDescedentsMap</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>if you would like to use just symbol itself as the hash head, remove these four lines below and other correlative stuffs.<br/>
{symbol: tag}, from rule symbol map to a shorter memo tag, for memory efficeny</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> symbolToTagMap</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>{tag: True}, record tags that has been used to avoid conflict</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">global</span> tags

<span class="keyword">global</span> parseCache <span class="comment"># {tag+start: [result, cursor]}, memorized parser result</span>
<span class="keyword">global</span> functionCache <span class="comment"># memorized normal function result</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h4>helper functions</h4>
<p>some functions is helpful to make the parser.</p>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p><strong>intialize</strong>: clear global varialbes. you should call <code>intialize()</code> at first.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(aGrammar)</span>:</span>
  <span class="keyword">global</span> grammar, parseCache, functionCache, originalRules, recursiveRules, symbolDescedentsMap,\
         symbolToTagMap, tags
  grammar = aGrammar
  grammar.parentToChildren = {}
  parseCache = {}
  functionCache = {}
  originalRules = {}
  recursiveRules = {}
  symbolDescedentsMap = {}
  symbolToTagMap = {}
  tags = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><strong>_parse</strong>: parse <strong>$data</strong> from <strong>$root</strong> with <strong>$aGrammar</strong>.<br/>
before parsing, you should tell the informations about left recursion in grammar.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(data, aGrammar, root=None)</span>:</span>
  <span class="keyword">global</span> text, textLength, cursor 
  text = data
  textLength = len(text)
  cursor = <span class="number">0</span>
  root = root <span class="keyword">or</span> aGrammar.rootSymbol
  <span class="keyword">return</span> getattr(grammar, root)(<span class="number">0</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p><a id="peasysample"></a>
<strong>parse</strong>: this is a sample parse function to demonstrate on how to write your own grammar rules yourself.<br/>
notice that there exists indirect left recursion in the grammar.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">parseSample</span><span class="params">(text)</span>:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>generate the matchers by the combinators in advance for better performance.<br/>
if you don&#39;t mind performance, you can write them in the rule directly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  a = char(<span class="string">'a'</span>); b = char(<span class="string">'b'</span>); x = char(<span class="string">'x'</span>)
  memoA = memo(<span class="string">'A'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>the grammar rules object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="class"><span class="keyword">class</span> <span class="title">rules</span>:</span>
    rootSymbol = <span class="string">'A'</span>    
    <span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(self,start)</span>:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><em>add <code>or memoResult</code> to prevent executing nonrecursive part more than once.</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      memoResult = m = rules.B(start)
      <span class="keyword">return</span> (m <span class="keyword">and</span> x(p.cur()) <span class="keyword">and</span> m+<span class="string">'x'</span> <span class="keyword">or</span> memoResult) <span class="keyword">or</span> a(start)
    <span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">(self,start)</span>:</span> <span class="keyword">return</span> rules.C(start)
    <span class="function"><span class="keyword">def</span> <span class="title">C</span><span class="params">(self,start)</span>:</span> <span class="keyword">return</span> memoA(start) <span class="keyword">or</span> b(start)
  initialize()
  addRecursiveCircles(rules, [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])
  computeLeftRecursives(rules)
  parse(text, rules)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h5>stuffs for left recursives</h5>
<p>use <code>addParentChildren(grammar, parentChildrens)</code> or <code>addRecursiveCircles(grammar, recursiveCircles...)</code> to tell
the left calling relations between symbols in the grammar<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><strong>addParentChildrens</strong>: add direct left call parent-&gt;children relation for <strong>$parentChildrens</strong> to <strong>@symbolToParentsMap</strong><br/>
e.g. <code>addRecursiveCircles(grammar, {A:[&#39;B&#39;], B:[&#39;A&#39;, &#39;B&#39;]})</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">addParentChildrens</span><span class="params">(grammar, parentChildren)</span>:</span>
  map = grammar.parentToChildren
  <span class="keyword">for</span> parent, children <span class="keyword">in</span> parentChildren:
    list = map.setdefault(parent, [])
    <span class="keyword">for</span> name <span class="keyword">in</span> children:
      <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> list: list.append(name)</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><strong>addRecursiveCircles</strong>: add left recursive parent-&gt;children relation to <code>grammar.parentToChildren</code> for symbols in <strong>@recursiveCircles</strong><br/>
e.g. <code>addRecursiveCircles(grammar, [&#39;A&#39;, &#39;B&#39;], [&#39;B&#39;])</code> tell the same left recursive relations as above sample.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">addRecursiveCircles</span><span class="params">(grammar, *recursiveCircles)</span>:</span>
  map = grammar.parentToChildren
  <span class="keyword">for</span> circle <span class="keyword">in</span> recursiveCircles:
    length = len(circle)
    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):
      <span class="keyword">if</span> i==length-<span class="number">1</span>: j = <span class="number">0</span> 
      <span class="keyword">else</span>: j = i+<span class="number">1</span>
      name = circle[i]
      parent = circle[j]
      list = map.setdefault(parent, [])
      <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> list: list.append(name)</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><strong>computeLeftRecursives</strong>: after telling left recursive relations, compute the left recsives group and wrap symbol in
them with <code>recursive</code> function<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">computeLeftRecursives</span><span class="params">(grammar)</span>:</span>
  <span class="keyword">global</span> symbolDescedentsMap, originalRules
  parentToChildren = grammar.parentToChildren
  <span class="function"><span class="keyword">def</span> <span class="title">addDescendents</span><span class="params">(symbol, meetTable, descedents)</span>:</span>
    children =  parentToChildren[symbol]
    <span class="keyword">for</span> child <span class="keyword">in</span> children:
      <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> descedents: descedents.append(child)
      <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> meetTable: addDescendents(child, meetTable, descedents)
  symbolDescedentsMap = {}
  <span class="keyword">for</span> symbol <span class="keyword">in</span> parentToChildren:
    meetTable = {}; meetTable[symbol] = <span class="built_in">True</span>
    descendents = symbolDescedentsMap[symbol] = []
    addDescendents(symbol, meetTable, descendents)
    <span class="keyword">if</span> symbol <span class="keyword">in</span> descendents:
      originalRules[symbol] = getattr(grammar, symbol)
      setattr(grammar, symbol, recursive(symbol))
  symbolDescedentsMap</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong>recursive</strong>: this is the key function to left recursive.<br/>
Make <strong>$symbol</strong> a left recursive symbol, which means to wrap <code>originalRules[symbol]</code> with recursive.
when recursiv(symbol)(start) is executed, first let <code>rule = grammar[symbol]</code>, <code>grammar[symbol] = originalRules[child]</code> for
all symbols in left recursive circles and loop computing rule(start) until no changes happened, and
restore all symbols in left recursive cirle to <code>recursiveRules[symbol]</code> at last.,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(symbol)</span>:</span>
  rule = originalRules[symbol]
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    <span class="keyword">for</span> child <span class="keyword">in</span> symbolDescedentsMap[symbol]:
      setattr(grammar, child, originalRules[child])
    hash = symbol+str(start)
    m = parseCache.setdefault(hash, [<span class="built_in">None</span>, -<span class="number">1</span>])
    <span class="keyword">if</span> m[<span class="number">1</span>]&gt;=<span class="number">0</span>: cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> m[<span class="number">0</span>]
    <span class="keyword">while</span> <span class="number">1</span>:
      result = rule(start)
      <span class="keyword">if</span> m[<span class="number">1</span>]&lt;<span class="number">0</span>:
        m[<span class="number">0</span>] = result
        <span class="keyword">if</span> result:  m[<span class="number">1</span>] = cursor
        <span class="keyword">else</span>: m[<span class="number">1</span>] = start
      <span class="keyword">else</span>:
        <span class="keyword">if</span> m[<span class="number">1</span>]==cursor: m[<span class="number">0</span>] = result; <span class="keyword">return</span> result
        <span class="keyword">elif</span> cursor&lt;m[<span class="number">1</span>]: m[<span class="number">0</span>] = result; cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> result
        <span class="keyword">else</span>: m[<span class="number">0</span>] = result; m[<span class="number">1</span>] = cursor
    <span class="keyword">for</span> child <span class="keyword">in</span> symbolDescedentsMap[symbol]:
      grammar[child] = recursiveRules[child]
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap for-h5">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h5>memorization</h5>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><strong>memo</strong>: lookup the memorized result and reached cursor for <strong>$symbol</strong> at the position of <strong>$start</strong><br/>
It is set up automaticly by <code>computeLeftRecursives(grammar)</code> for the symbols which is left recursive.<br/>
For other symbol, you should be able to call this in rule mannually.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(symbol)</span>:</span>
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> parseCache, cursor
    hash = symbol+str(start)
    <span class="keyword">try</span>: 
      m = parseCache[hash]
      <span class="keyword">if</span> m: cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> m[<span class="number">0</span>]
    <span class="keyword">except</span>: <span class="keyword">return</span>       
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><strong>setMemorizeRules</strong>: set the symbols in grammar which  memorize their rule&#39;s result.<br/>
this function should be used only for the symbols which is not left recursives.<br/>
you can do this after <code>initialize()</code> and before <code>parse(...)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">setMemorizeRules</span><span class="params">(grammar, symbols)</span>:</span>
  <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:
    originalRules[symbol] = grammar[symbol]
    grammar[symbol] = memorize(symbol)</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><strong>memorize</strong>: memorize result and cursor for <strong>$symbol</strong> which is not left recursive.<br/>
<em>The symbols which is left recursive should be wrapped by <code>recursive(symbol)</code>, not <code>memorize(symbol)</code>!!!</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">memorize</span><span class="params">(symbol)</span>:</span>
  tag = symbolToTagMap[symbol]
  rule = originalRules[symbol]
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    hash = tag+start
    m = parseCache[hash]
    <span class="keyword">if</span> m: cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> m[<span class="number">0</span>]
    <span class="keyword">else</span>:
      result = rule(start)
      parseCache[hash] = [result, cursor]
      <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><strong>setMemoTag</strong>: find a shorter part of symbol as the head of hash tag to index <strong>@parseCache</strong> <br/>
It exists just for performance reason. If you don&#39;t like this idea, you can remove the stuffs about memo tag yourself and
just use symbol itself as the head of hash tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">setMemoTag</span><span class="params">(symbol)</span>:</span>
  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(symbol)):
    <span class="keyword">if</span> symbol[<span class="number">0</span>:i] <span class="keyword">not</span> <span class="keyword">in</span> tags: <span class="keyword">break</span>
  tag = symbol[<span class="number">0</span>:i]
  symbolToTagMap[symbol] = tag
  tags[tag] = <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h4>matchers and matcher combinators<br/></h4>

            </div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>A <strong>matcher</strong> is a function which read the text being parsed and move cursor directly.<br/>
All matcher should return truth value on succeed, and return falsic value on fail.<br/>
A <strong>combinator</strong> is a function which receive zero or more matchers as parameter(maybe plus some other parameters
which are not matchers), and generate a new matchers.<br/>
there are other matcher generator besides the standard combinators described as above, like <code>recursive</code>, <code>memo</code>, <code>memorize</code>,
which we have met above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="function"><span class="keyword">def</span> <span class="title">isMatcher</span><span class="params">(item)</span>:</span>  <span class="keyword">return</span> hasattr(obj, <span class="string">'__call__'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>combinator <strong>andp</strong><br/>
execute item(cursor) in sequence, return the result of the last one. <br/>
when <code>andp</code> is used to combined of the matchers, the effect is the same as by using the Short-circuit evaluation, like below:<br/>
<code>item1(start) and item2(cursor] ... and itemn(cursor).</code>  <br/>
In fact, you maybe would rather like to use <code>item1(start) and item2(cursor) ..</code> when you write the grammar rule in the
manner of Peasy. That would be simpler, faster and more elegant. <br/>
And in that manner, you would have more control on your grammar rule, say like below: <br/>
<code>if (x=item1(start) and (x&gt;100) and item2(cursor) and not item3(cursor) and (y = item(cursor)): doSomething()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">andp</span><span class="params">(items)</span>:</span>
  items1 = []
  <span class="keyword">for</span> item <span class="keyword">in</span> items:
    <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): items1.append(literal(item))
    <span class="keyword">else</span>: items1.append(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    <span class="keyword">for</span> item <span class="keyword">in</span> items1:
      result = item(cursor)
      <span class="keyword">if</span> <span class="keyword">not</span>(result): <span class="keyword">return</span>
    <span class="keyword">return</span> result</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>combinator <strong>orp</strong> <br/>
execute <code>item(start)</code> one by one, until the first item which is evaluated to truth value and return the value.<br/>
when orp is used to combined of the matchers, the effect is the same as by using the Short-circuit evaluation, like below:<br/>
item1(start) or item2(cursor] ... or itemn(cursor) <br/>
In fact, you maybe would rather like to use <code>item1(start) or item2(cursor) ..</code> when you write the grammar rule in the
manner of Peasy. That would be simpler, faster and more elegant. <br/>
And in that manner, you would have more control on your grammar rule, say like below: <br/>
<code>if ((x=item1(start) and (x&gt;100)) or (item2(cursor) and not item3(cursor)) or (y = item(cursor)): doSomething()</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">orp</span><span class="params">(*items)</span>:</span>
  items1 = []
  <span class="keyword">for</span> item <span class="keyword">in</span> items:
    <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): items1.append(literal(item))
    <span class="keyword">else</span>: items1.append(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">for</span> item <span class="keyword">in</span> items1:
      result = item(start)
      <span class="keyword">if</span> result: <span class="keyword">return</span> result
    <span class="keyword">return</span> result</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>combinator <strong>notp</strong><br/>
<code>notp</code> is not useful except being used in other combinators, just like this: <code>andp(item1, notp(item2))</code>.<br/>
<em>It&#39;s unnessary, low effecient and ugly to write <code>notp(item)(start)</code>, just write <code>not item(start)</code>.</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">notp</span><span class="params">(item)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span> <span class="keyword">return</span> <span class="keyword">not</span> item(start)
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>combinator <strong>any</strong>: zero or more times of <code>item(cursor)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">any</span><span class="params">(item)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    result = []; cursor = start
    <span class="keyword">while</span> <span class="number">1</span>:
      x = item(cursor)
      <span class="keyword">if</span> x: result.append(x)
      <span class="keyword">else</span>: <span class="keyword">break</span>
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>combinator <strong>some</strong>: one or more times of <code>item(cursor)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">some</span><span class="params">(item)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    result = []; cursor = start
    x = item(cursor)
    <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> x
    <span class="keyword">while</span> <span class="number">1</span>:
      result.append(x)
      x = item(cursor)
      <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">break</span>
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>combinator  <strong>may</strong>: a.k.a optional <br/>
try to match <code>item(cursor)</code>, wether <code>item(cursor)</code> succeed or not, <code>maybe(item)(start)</code> succeed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">optional</span><span class="params">(item)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    x = item(cursor)
    <span class="keyword">if</span> x: <span class="keyword">return</span> x
    <span class="keyword">else</span>: cursor = start; <span class="keyword">return</span> <span class="built_in">True</span>
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>combinator <strong>follow</strong> <br/>
try to match <code>item(start)</code>, if succeed, reset cursor and return the value of item(start) <br/>
whether succeed or not, cursor is reset to start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(item)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    x = item(cursor)
    <span class="keyword">if</span> x: cursor = start; <span class="keyword">return</span> x
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>combinator <strong>times</strong>: match <strong>$n</strong> times item(cursor), n&gt;=1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">times</span><span class="params">(item, n)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):
      x = item(cursor)
      <span class="keyword">if</span> x: result.append(x)
      <span class="keyword">else</span>: <span class="keyword">return</span>
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>combinator <strong>seperatedList</strong>: some times item(cursor), separated by @separator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">seperatedList</span><span class="params">(item, separator=None)</span>:</span>
  <span class="keyword">if</span> separator <span class="keyword">is</span> <span class="built_in">None</span>: separator = spaces
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(separator): separator = literal(separator)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    result = []
    x = item(cursor)
    <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span>
    <span class="keyword">while</span> <span class="number">1</span>:
      result.append(x)
      x = item(cursor)
      <span class="keyword">if</span> <span class="keyword">not</span>(x): <span class="keyword">break</span>
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>combinator <strong>timesSeperatedList</strong>: given @n times $item separated by @separator, n&gt;=1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">timesSeperatedList</span><span class="params">(item, n, separator=None)</span>:</span>
  <span class="keyword">if</span> separator <span class="keyword">is</span> <span class="built_in">None</span>: separator = spaces
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(separator): separator = literal(separator)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    cursor = start
    result = []
    x = item(cursor)
    <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> ranges(n-<span class="number">1</span>):
      result.append(x)
      x = item(cursor)
      <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">break</span>
    <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>As the same as andp, orp, in the manner of Peasy, you would rather to write youself a loop to do the things, instead
of useing the combinators like any, some, times, seperatedList,etc. and that would be simpler, faster and more elegant. <br/>
And in that manner, you would have more control on your grammar rule so that we can do other things include lexer,
error report, errer recovery, semantic operatons, and any other things you would like to do. <br/></p>

            </div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>It is for three motives to put all of the stuffs abve here:
<em> 1. to demonstrate how to write matcher and grammar rules in the method brought by Peasy
</em> 2. to demonstrate that Peasy can implement any component that other combinational parser libaries like pyparsing,
parsec too, but in a simpler, faster manner.
* 3. to show that it is how easy to write the matchers in the manner of Peasy.<br/><br/></p>

            </div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>As you have seen above, all of these utilities is so simple that you can write them at home by hand easily. In fact,
you can write yourself all of the grammar rules in the same manner as above.</p>

            </div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>If you like, you can add a faster version for every matcher, which do not pass $start as parameter around.<br/>
Some of the matchers below have two version, to demonstrate how to do that.
<em>Don&#39;t use the faster version in orp, any, some, times, separatedList, timesSeparatedList.</em> <br/><br/></p>

            </div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap for-h4">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h4>some other matchers, combinators and predicate<br/></h4>
<p>A <strong>predicate</strong> is a function which return True or False, usually according to its parameter, but not look at parsed object.
below is some little utilities may be useful. Three version of some of them is provided.<br/>
just remove them if you don&#39;t need them, except <strong>literal</strong>, which is depended by the matchers above.</p>

            </div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>matcher <strong>literal</strong>, normal version<br/>
match a text string.<br/>
`notice: some combinators like andp, orp, notp, any, some, etc. use literal to wrap a object which is not a matcher.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="function"><span class="keyword">def</span> <span class="title">literal</span><span class="params">(string)</span>:</span> 
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    len = string.length
    stop = start+len
    <span class="keyword">if</span> text[start:stop]==string: cursor = stop; <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>matcher <strong>literal_</strong>, faster version<br/>
match a text string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">iteral_</span><span class="params">(string)</span>:</span> 
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    len = string.length
    <span class="keyword">if</span> text.slice(cursor,  stop = cursor+len)==string: 
      cursor = stop; <span class="keyword">return</span> <span class="built_in">True</span>
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>matcher <strong>char</strong>, normal version<br/>
match one character</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">char</span><span class="params">(c)</span>:</span> 
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    <span class="keyword">if</span> start&gt;=textLength: <span class="keyword">return</span>
    <span class="keyword">if</span> text[start]==c: cursor = start+<span class="number">1</span>; <span class="keyword">return</span> c
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>matcher <strong>char_</strong>, normal version <br/>
match one character</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">char_</span><span class="params">(c)</span>:</span> 
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">()</span>:</span>
    <span class="keyword">global</span> cursor
    <span class="keyword">if</span> text[cursor]==c: cursor += <span class="number">1</span>; <span class="keyword">return</span> c
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>In spaces, spaces<em>, spaces1, spaces1</em>, a tat(&#39;\t&#39;) is seen as tabWidth spaces, <br/>
which is used in indent style language, such as coffeescript, python, haskell, etc. <br/>
If you don&#39;t need this feature, you can easily rewrite these utilities to remove the code about tab width yourself.<br/><br/></p>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>matcher <strong>spaces</strong>, normal version<br/>
zero or more whitespaces, ie. space or tab.<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">spaces</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  len = <span class="number">0</span>
  cursor = start
  text = text
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    cursor += <span class="number">1</span>
    <span class="keyword">if</span> c==<span class="string">' '</span>: len += <span class="number">1</span>
    <span class="keyword">elif</span> c==<span class="string">'\t'</span>: len += tabWidth
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="keyword">return</span> len</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>matcher <strong>spaces_</strong>, faster version<br/>
zero or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">spaces_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  len = <span class="number">0</span>
  text = text
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    cursor += <span class="number">1</span>
    <span class="keyword">if</span> c==<span class="string">' '</span>: len += <span class="number">1</span>
    <span class="keyword">elif</span> c==<span class="string">'\t'</span>: len += tabWidth
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="keyword">return</span> len</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>matcher <strong>spaces1</strong>, normal version<br/>
one or more whitespaces, ie. space or tab.<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">spaces1</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  len = <span class="number">0</span>
  cursor = start
  text = text
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    cursor += <span class="number">1</span>
    <span class="keyword">if</span> c==<span class="string">' '</span>: len += <span class="number">1</span>
    <span class="keyword">elif</span> c==<span class="string">'\t'</span>: len += tabWidth
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="keyword">if</span> len: <span class="keyword">return</span> len</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>matcher <strong>spaces1_</strong>, faster version<br/>
one or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">spaces1_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  len = <span class="number">0</span>
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    cursor += <span class="number">1</span>
    <span class="keyword">if</span> c==<span class="string">' '</span>: len += <span class="number">1</span>
    <span class="keyword">elif</span> c==<span class="string">'\t'</span>: len += tabWidth
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="keyword">if</span> len: <span class="keyword">return</span> len</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>matcher <strong>wrap</strong>, normal version<br/>
match left,: match item, match right at last</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(item, left=spaces, right=spaces)</span>:</span>
  <span class="keyword">if</span> <span class="keyword">not</span> isMatcher(item): item = literal(item)
  <span class="function"><span class="keyword">def</span> <span class="title">matcher</span><span class="params">(start)</span>:</span>
    <span class="keyword">global</span> cursor
    <span class="keyword">if</span> <span class="keyword">not</span> left(start): <span class="keyword">return</span>
    result = item(cursor)
    <span class="keyword">if</span> result <span class="keyword">and</span> right(cursor): <span class="keyword">return</span> result
  <span class="keyword">return</span> matcher</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>matcher <strong>identifierLetter</strong>: normal version<br/>
is a letter than can be used in identifer?<br/>
javascript style, &#39;$&#39; is a identifierLetter_<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">identifierLetter</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  cursor = start
  c = text[cursor]
  <span class="keyword">if</span> c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>:
    cursor += <span class="number">1</span>; 
    <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>matcher <strong>identifierLetter_</strong>, version<br/>
is a letter that can be used in identifer? <br/>
javascript style, &#39;$&#39; is a identifierLetter_</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">identifierLetter_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[cursor]
  <span class="keyword">if</span> c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>:
    cursor += <span class="number">1</span>; 
    <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>matcher <strong>followIdentifierLetter_</strong>, faster version<br/>
lookahead whether the following character is a letter used in identifer. don&#39;t change cursor. <br/>
javascript style, &#39;$&#39; is a identifierLetter_</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">followIdentifierLetter_</span><span class="params">()</span>:</span>
  c = text[cursor]
  <span class="keyword">return</span> c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>

<span class="function"><span class="keyword">def</span> <span class="title">isIdentifierLetter</span><span class="params">(c)</span>:</span> <span class="keyword">return</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>predicate isdigit<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">isdigit</span><span class="params">(c)</span>:</span> <span class="keyword">return</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>matcher digit, normal version<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">digit</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[start];  
  <span class="keyword">if</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>: cursor = start+<span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>matcher digit_, faster version<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">digit_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[cursor];  
  <span class="keyword">if</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>: cursor += <span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>predicate isletter<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">isalpha</span><span class="params">(c)</span>:</span> <span class="keyword">return</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>
isletter = isalpha</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>matcher letter, normal version<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">alpha</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[start]; 
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>: cursor = start+<span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span>
letter = alpha</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>matcher letter, faster version<br/></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">alpha_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[cursor]; 
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>: cursor += <span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span>
letter_ = alpha_</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>predicate: islower</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">islower</span><span class="params">(c)</span>:</span> <span class="keyword">return</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>matcher lower, normal version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">lower</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[start]; 
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span>: cursor = start+<span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>matcher lower_, faster version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">lower_</span><span class="params">()</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[cursor]; 
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span>: cursor += <span class="number">1</span>; <span class="keyword">return</span> <span class="built_in">True</span>

<span class="function"><span class="keyword">def</span> <span class="title">isupper</span><span class="params">(c)</span>:</span> <span class="keyword">return</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>matcher upper, normal version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">upper</span><span class="params">(start)</span>:</span> 
  <span class="keyword">global</span> cursor
  c = text[start]; 
  <span class="keyword">if</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>: cursor = start+<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>matcher upper_, faster version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">upper_</span><span class="params">(start)</span>:</span> 
  <span class="keyword">global</span> cursor
  c = text[cursor]; 
  <span class="keyword">if</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>: cursor += <span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>matcher identifier, normal version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">identifier</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  cursor = start
  c = text[cursor]
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span>: cursor += <span class="number">1</span>
  <span class="keyword">else</span>: <span class="keyword">return</span>
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span>: cursor += <span class="number">1</span>
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>matcher identifier_, faster version</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">identifier_</span><span class="params">(start)</span>:</span>
  <span class="keyword">global</span> cursor
  c = text[cursor]
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span>: cursor += <span class="number">1</span>
  <span class="keyword">else</span>: <span class="keyword">return</span>
  <span class="keyword">while</span> <span class="number">1</span>:
    c = text[cursor]
    <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span>: cursor += <span class="number">1</span>
    <span class="keyword">else</span>: <span class="keyword">break</span>
  <span class="built_in">True</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>The utilites above is just for providing some examples on how to write matchers for Peasy.<br/>
In fact, It&#39;s realy easy peasy to write the matchers for your grammar rule yourself.<br/>
see <a href="http://en.wiktionary.org/wiki/easy_peasy">easy peasy</a> <br/></p>

            </div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>These utilities below exists for people who want to use these file a independent module, and put the grammar rule in
another separated file.<br/></p>

            </div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>gettext: get the being pased text<br/>
If you use this file to contain the grammar rules, just directly use <code>text</code><br/>
and use <code>text[cursor]</code> to get current character, <code>text.slice(cursor, cursor+n)</code> to get substring of the text, if
text is a string object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">gettext</span><span class="params">()</span>:</span> <span class="keyword">return</span> text</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>If you use this file to contain the grammar rules, just directly use <code>cursor</code> or <code>cursor = n</code> or <code>cursor += 1</code> or <code>cursor--</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">def</span> <span class="title">cur</span><span class="params">()</span>:</span> <span class="keyword">return</span> cursor
<span class="function"><span class="keyword">def</span> <span class="title">setcur</span><span class="params">(pos)</span>:</span> 
  <span class="keyword">global</span> cursor
  cursor = pos
  <span class="keyword">return</span> cursor</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>It&#39;s a pity that assign in python is a statement and can not occur in expression.<br/>
So We can not write x = Additive(start) and op = Op(cursor) and y = Multiply(cursor) and op(x, y)<br/>
As a workaround, we assign some Var beforehand, e.g. x, y, op = vars(3)
and then we can write like this:<br/> 
x.set(Additive(start)) and op &lt;&lt; Op(cursor) and y &lt;&lt; Multiply(cursor) and op(x, y)
we can also wrtie like below:<br/> 
x &lt;&lt; Additive(start) and op &lt;&lt; Op(cursor) and y &lt;&lt; Multiply(cursor) and op.v(x.v, y.v)<br/> 
If you do not need them, you may remove any overload definitions below except left shift. <br/> 
And you can use var.v at every place and remove all of the overload definitions, and that will make program faster.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="function"><span class="keyword">def</span> <span class="title">vars</span><span class="params">(n)</span>:</span> [Var() <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]

<span class="class"><span class="keyword">class</span> <span class="title">Var</span>:</span>
  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">''</span>)</span>:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>name is unnecessary attribute. remove it if you like.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.name = name
    self.v = <span class="built_in">None</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>faked assignment  </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="keyword">def</span> <span class="title">__lshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&lt;&lt;y</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>had best to reserve the truth overloading.
class Rules
  def Add(self, start):
     x, op, y = vars(3)
     return x &lt;&lt; memo(&#39;Add&#39;)(start) and op &lt;&lt; Op(cursor) and y &lt;&lt; Mul(cursor) and op.v(x.v, y.v) \
            or x\
            or Mul(start)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="keyword">def</span> <span class="title">__nonzero__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.v
  
  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span> self.name+<span class="string">':'</span>+repr(self.v)</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>You can overload the attribute of Var on demand.<br/>
Or overload none of them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&lt;y
  <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&lt;=y
  <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v==y
  <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v!=y
  <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&gt;y
  <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&gt;=y
  <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, attr, value)</span>:</span> 
    <span class="keyword">if</span> attr==<span class="string">'set'</span>: self.v = value; <span class="keyword">return</span> self
    <span class="keyword">return</span> getattr(self.v, attr, value)
  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span> 
    <span class="keyword">return</span> getattr(self.v, attr)
  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span> 
    args = [(arg.v <span class="keyword">if</span> isinstance(arg, Var) <span class="keyword">else</span> arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args]
    kwargs = {k:(v.v <span class="keyword">if</span> isinstance(v, Value) <span class="keyword">else</span> v) <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs}
    <span class="keyword">return</span> self.v(*args, **kwargs); 
  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v[key]
  <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v+y
  <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v-y
  <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v*y
  <span class="function"><span class="keyword">def</span> <span class="title">__floordiv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v//y
  <span class="function"><span class="keyword">def</span> <span class="title">__div__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v/y
  <span class="function"><span class="keyword">def</span> <span class="title">__truediv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v//y
  <span class="function"><span class="keyword">def</span> <span class="title">__mod__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v%y
  <span class="function"><span class="keyword">def</span> <span class="title">__pow__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v**y
  <span class="function"><span class="keyword">def</span> <span class="title">__rshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&gt;&gt;y
  <span class="function"><span class="keyword">def</span> <span class="title">__and__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v&amp;y
  <span class="function"><span class="keyword">def</span> <span class="title">__xor__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v^y
  <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> self.v|y
  <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y+self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rsub__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y-self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y*self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rfloordiv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y//self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rdiv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y/self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rtruediv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y/self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rmod__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y&amp;self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rpow__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y**self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rlshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">return</span> y&lt;&lt;self.vr
  <span class="function"><span class="keyword">def</span> <span class="title">__rshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y&gt;&gt;self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rand__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">return</span> y&amp;self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__rxor__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    <span class="keyword">return</span> y^self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">return</span> y|self.v;
  <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, y)</span>:</span> 
    self.v += y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__isub__</span><span class="params">(self, y)</span>:</span> 
    self.v -= y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__imul__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v *= y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__ifloordiv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v//=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__idiv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v/=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__itruediv__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v/=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__imod__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v%=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__ipow__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v**=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__ilshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v&lt;&lt;=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__irshift__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v&gt;&gt;=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__iand__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v&amp;=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__ixor__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v^=y; <span class="keyword">return</span> self
  <span class="function"><span class="keyword">def</span> <span class="title">__ior__</span><span class="params">(self, y)</span>:</span> 
    <span class="keyword">if</span> isinstance(y, Var): y = y.y
    self.v|=y; <span class="keyword">return</span> self

  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> iter(self.v)
  <span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>  <span class="keyword">return</span> -self.v&gt;=y
  <span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> +self.v
  <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> abs(self.v)
  <span class="function"><span class="keyword">def</span> <span class="title">__invert__</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> ~self.v</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
