<!DOCTYPE html>

<html>
<head>
  <title>Peasy</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Peasy</h1>
<h2>Peasy means parsing is easy</h2>
<h3>an easy but powerful parser</h3>
<p>With Peasy, you write the parser by hand, just like to write any other kind of program.
You need not play many balls like that any more:
<img src="https://raw.github.com/chaosim/peasy/master/ballacrobatics.jpg" alt="ballacrobatics.jpg">
You just play one ball like so:
<img src="https://raw.github.com/chaosim/peasy/master/dolphinball.jpg" alt="dolphinball.jpg">,</p>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Peasy provided two method to tell which symbol is left recursive.
here is the automiatic method:
You just write your rules normally, when parsing, you first call  intialize() and autoComputeLeftRecursives(grammar),
and then everything about left recursive symbols is automatic computed.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3>global variables</h3>
<p>It is for the performace that I use global variables, and I provided another version which have Parser class for
people who prefer more modular to speed.</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>some global variable used while parsing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
text = <span class="string">''</span> <span class="comment"># the text which is being parsed, this could be any sequence, not only strincs.</span>
textLength = <span class="number">0</span> <span class="comment"># the length of text</span>
cursor = <span class="number">0</span>  <span class="comment"># the current position of parsing, use text[cursor] to get current character in parsed stream</span>

grammar = <span class="literal">undefined</span>  <span class="comment"># the grammar object which contains all of rules defined for the symbol in grammar.</span>
originalRules = {} <span class="comment"># saved the original rules of the grammar.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>store the wrapped function to rule of the left recursive symbol, and before entering them, store it in grammar too.
when entering them, grammar[symbol] is unwrapped to originalRules[symbol] or memorizeRecursives[symbol]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>recursiveRules = {}
memorizedRecursivs = {}
memoRules = {}
symbolDescedentsMap = {}

symbolToTagMap = {}  <span class="comment"># {symbol: tag}, from rule symbol map to a shorter memo tag, for memory efficeny</span>
tags = {}  <span class="comment"># {tag: true}, record tags that has been used to avoid conflict</span>
parseCache = {} <span class="comment"># {tag+start: [result, cursor]}, memorized parser result</span>
functionCache = {} <span class="comment"># memorized normal function result</span>

hasOwnProperty = Object.hasOwnProperty</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>call intialize() at first</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.initialize = () -&gt;
  parseCache = {}
  functionCache = {}
  originalRules = {}
  recursiveRules = {}
  memorizedRecursivs = {}
  memoRules = {}
  symbolDescedentsMap = {}
  symbolToTagMap = {}
  tags = {}
  parseCache = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>parse @data from @root with @aGrammar function @root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">parse</span></span> = (data, aGrammar, root) -&gt;
  text = data
  textLength = text.length
  cursor = <span class="number">0</span>
  root = root <span class="keyword">or</span> aGrammar.rootSymbol
  grammar = aGrammar
  grammar[root](<span class="number">0</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>use addParentChildren(grammar, parentChildrens...) or addRecursiveCircles(grammar, recursiveCircles...) to tell
the left calling relations between symbols in the grammar</p>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>add direct left call parent-&gt;children relation for @parentChildrens to global variable symbolToParentsMap
e.g. addRecursiveCircles(grammar, {A:[&#39;B&#39;], B:[&#39;A&#39;, &#39;B&#39;]})</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">addParentChildrens</span></span> = (grammar, parentChildren) -&gt;
  map = grammar.parentToChildren ?= {}
  <span class="keyword">for</span> parent, children <span class="keyword">of</span> parentChildren
    list = map[parent] ?= []
    <span class="keyword">for</span> name <span class="keyword">in</span> children
      <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> list <span class="keyword">then</span> list.push name
  <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>add left recursive parent-&gt;children relation to @symbolToParentsMap for symbols in @recursiveCircles
e.g. addRecursiveCircles(grammar, [&#39;A&#39;, &#39;B&#39;], [&#39;B&#39;]) tell the same left recursive relations as above sample.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">addRecursiveCircles</span></span> = (grammar, recursiveCircles...) -&gt;
  map = grammar.parentToChildren ?= {}
  <span class="keyword">for</span> circle <span class="keyword">in</span> recursiveCircles
    i = <span class="number">0</span>
    length = circle.length
    <span class="keyword">while</span> i&lt;length
      <span class="keyword">if</span> i==length-<span class="number">1</span> <span class="keyword">then</span> j = <span class="number">0</span> <span class="keyword">else</span> j = i+<span class="number">1</span>
      name = circle[i]
      parent = circle[j]
      list = map[parent] ?= []
      <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> list <span class="keyword">then</span> list.push name
      i++
  <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>after telling left recursive relations, compute the left recsives group and wrap symbol in them with recursive function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">computeLeftRecursives</span></span> = (grammar) -&gt;
  parentToChildren = grammar.parentToChildren
  <span class="function"><span class="title">addDescendents</span></span> = (symbol, meetTable, descedents) -&gt;
    children =  parentToChildren[symbol]
    <span class="keyword">for</span> child <span class="keyword">in</span> children
      <span class="keyword">if</span> child <span class="keyword">not</span> <span class="keyword">in</span> descedents <span class="keyword">then</span> descedents.push child
      <span class="keyword">if</span> <span class="keyword">not</span> meetTable[child] <span class="keyword">then</span> addDescendents(child, meetTable, descedents)
  symbolDescedentsMap = {}
  <span class="keyword">for</span> symbol <span class="keyword">of</span> parentToChildren
    meetTable = {}; meetTable[symbol] = <span class="literal">true</span>
    descendents = symbolDescedentsMap[symbol] = []
    addDescendents(symbol, meetTable, descendents)
    <span class="keyword">if</span> symbol <span class="keyword">in</span> descendents
      originalRules[symbol] = grammar[symbol]
      grammar[symbol] = recursive(symbol)
  symbolDescedentsMap</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>this is the key function to left recursive.
Make @symbol a left recursive symbol, which means to wrap originalRules[symbol] with recursive.
when recursiv(symbol)(start) is executed, first let rule = grammar[symbol], grammar[symbol] = originalRules[child] for
all symbols in left recursive circles and loop computing rule(start) until no changes happened, and
restore all symbols in left recursive cirle to recursiveRules[symbol] at last.,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.recursive = <span class="function"><span class="title">recursive</span></span> = (symbol) -&gt;
  rule = grammar[symbol]
  (start) -&gt;
    <span class="keyword">for</span> child <span class="keyword">in</span> symbolDescedentsMap[symbol]
      grammar[child] = originalRules[child]
    hash = symbol+start
    m = parseCache[hash] ?= [<span class="literal">undefined</span>, -<span class="number">1</span>]
    <span class="keyword">if</span> m[<span class="number">1</span>]&gt;=<span class="number">0</span> <span class="keyword">then</span> cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> m[<span class="number">0</span>]
    <span class="keyword">while</span> <span class="number">1</span>
      result = rule(start)
      <span class="keyword">if</span> m[<span class="number">1</span>]&lt;<span class="number">0</span>
        m[<span class="number">0</span>] = result
        <span class="keyword">if</span> result <span class="keyword">then</span>  m[<span class="number">1</span>] = cursor
        <span class="keyword">else</span> m[<span class="number">1</span>] = start
        <span class="keyword">continue</span>
      <span class="keyword">else</span>
        <span class="keyword">if</span> m[<span class="number">1</span>]==cursor <span class="keyword">then</span> m[<span class="number">0</span>] = result; <span class="keyword">return</span> result
        <span class="keyword">else</span> <span class="keyword">if</span> cursor&lt;m[<span class="number">1</span>] <span class="keyword">then</span> m[<span class="number">0</span>] = result; cursor = m[<span class="number">1</span>]; <span class="keyword">return</span> result
        <span class="keyword">else</span> m[<span class="number">0</span>] = result; m[<span class="number">1</span>] = cursor
    <span class="keyword">for</span> child <span class="keyword">in</span> symbolDescedentsMap[symbol]
      grammar[child] = recursiveRules[child]
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>set a shorter start part of symbol as the tag used in parseCache</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">setMemoTag</span></span> = (symbol) -&gt;
  i = <span class="number">1</span>
  <span class="keyword">while</span> <span class="number">1</span>
    <span class="keyword">if</span> hasOwnProperty.call(tags, symbol.slice(<span class="number">0</span>, i)) <span class="keyword">in</span> tags <span class="keyword">then</span> i++
    <span class="keyword">else</span> <span class="keyword">break</span>
  tag = symbol.slice(<span class="number">0</span>, i)
  symbolToTagMap[symbol] = tag
  tags[tag] = <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>set the symbols in grammar which  memorize their rule&#39;s result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">setMemorizeRules</span></span> = (grammar, symbols) -&gt;
  <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols
    originalRules[symbol] = grammar[symbol]
    grammar[symbol] = memorize(symbol)</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>memorize result and cursor for @symbol which is not left recursive.
left recursive should be wrapped by recursive(symbol)!!!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">memorize</span></span> = (symbol) -&gt;
  tag = symbolToTagMap[symbol]
  rule = originalRules[symbol]
  (start) -&gt;
    hash = tag+start
    m = parseCache[hash]
    <span class="keyword">if</span> m <span class="keyword">then</span> cursor = m[<span class="number">1</span>]; m[<span class="number">0</span>]
    <span class="keyword">else</span>
      result = rule(start)
      parseCache[hash] = [result, cursor]
      result</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>lookup the memorized result and reached cursor for @symbol at the position of @start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.memo = <span class="function"><span class="title">memo</span></span> = (symbol) -&gt;
  (start) -&gt;
    hash = symbol+start
    m = parseCache[hash]
    <span class="keyword">if</span> m <span class="keyword">then</span> m[<span class="number">0</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>matchers and matcher combinators</p>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>any matcher should not return a value which is not null or undefined on succeed, except the root symbol.</p>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>compute exps in sequence, return the result of the last one.
andp and orp are used to compose the matchers
the effect is the same as by using the Short-circuit evaluation, like below:
exps<a href="start">0</a> and exps[2](cursor] ... and exps<a href="cursor">exps.length-1</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">andp</span></span> = (exps) -&gt;
  exps = <span class="keyword">for</span> exp <span class="keyword">in</span> exps
    <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> literal(exp) <span class="keyword">else</span> exp
  (start) -&gt;
    cursor = start
    <span class="keyword">for</span> exp <span class="keyword">in</span> exps
      <span class="keyword">if</span> <span class="keyword">not</span>(result = exp(cursor)) <span class="keyword">then</span> <span class="keyword">return</span>
    <span class="keyword">return</span> result</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>compute exps in parallel, return the result of the first which is not evaluated to false.
the effect is the same as by using the Short-circuit evaluation, like below:
exps<a href="start">0</a> or exps[2](cursor] ... or exps<a href="cursor">exps.length-1</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">orp</span></span> = (exps...) -&gt;
  exps = <span class="keyword">for</span> exp <span class="keyword">in</span> exps
    <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> literal(exp) <span class="keyword">else</span> exp
  (start) -&gt;
    <span class="keyword">for</span> exp <span class="keyword">in</span> exps
      <span class="keyword">if</span> result = exp(start) <span class="keyword">then</span> <span class="keyword">return</span> result
      <span class="keyword">return</span> result</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>applicaton of not operation
notp is not useful  except to compose the matchers.
It&#39;s not unnessary, low effecient and ugly to write &quot;notp(exp)(start)&quot;,
so don&#39;t write &quot;notp(exp)(start)&quot;, instead &quot;not exp(start)&quot;.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">notp</span></span> = (exp) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt; <span class="keyword">not</span> exp(start)</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>any: zero or more times of @exp(start)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">any</span></span> = (exp) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt;
    result = []; cursor = start
    <span class="keyword">while</span> ( x = exp(cursor)) <span class="keyword">then</span> result.push(x)
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>any: one or more times of @exp(start)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">some</span></span> = (exp) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt;
    result = []; cursor = start

    <span class="keyword">if</span> <span class="keyword">not</span> (x = exp(cursor)) <span class="keyword">then</span> <span class="keyword">return</span> x
    <span class="keyword">while</span> <span class="number">1</span>
      result.push(x)
      x = exp(cursor)
      <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span> <span class="keyword">break</span>
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>maybe exp(start)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.may = exports.<span class="function"><span class="title">optional</span></span> = (exp) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt;
    cursor = start
    <span class="keyword">if</span> x = exp(cursor) <span class="keyword">then</span> x
    <span class="keyword">else</span> cursor = start; <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>follow exp(start)?
whether succeed or not, cursor is reset to start</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">follow</span></span> = (exp) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt;
    cursor = start
    <span class="keyword">if</span> x = exp(cursor) <span class="keyword">then</span> cursor = start; x</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>given @n times @exp, n&gt;=1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">times</span></span> = (exp, n) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  (start) -&gt;
    cursor = start; i = <span class="number">0</span>
    <span class="keyword">while</span> i++&lt;n
      <span class="keyword">if</span> x = exp(cursor) <span class="keyword">then</span> result.push(x)
      <span class="keyword">else</span> <span class="keyword">return</span>
    <span class="keyword">return</span> result</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>some times @exp separated by @separator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">seperatedList</span></span> = (exp, separator=spaces) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  <span class="keyword">if</span> isString(separator) <span class="keyword">then</span> separator = literal(separator)
  (start) -&gt;
    cursor = start
    result = []
    x = exp(cursor)
    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span> <span class="keyword">return</span>
    <span class="keyword">while</span> <span class="number">1</span>
      result.push(x)
      <span class="keyword">if</span> <span class="keyword">not</span>(x = exp(cursor)) <span class="keyword">then</span> <span class="keyword">break</span>
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>given @n times @exp separated by @separator, n&gt;=1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">timesSeperatedList</span></span> = (exp, n, separator=spaces) -&gt;
  <span class="keyword">if</span> isString(exp) <span class="keyword">then</span> exp = literal(exp)
  <span class="keyword">if</span> isString(separator) <span class="keyword">then</span> separator = literal(separator)
  (start) -&gt;
    cursor = start
    result = []
    x = exp(cursor)
    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">then</span> <span class="keyword">return</span>
    i = <span class="number">1</span>
    <span class="keyword">while</span> i++&lt;n
      result.push(x)
      <span class="keyword">if</span> <span class="keyword">not</span>(x = exp(cursor)) <span class="keyword">then</span> <span class="keyword">break</span>
    result</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>As you have seen above, all of these utilities is so simple that you can write them at home by hand.
To put it them here, it is just being used to demonstrate how easy to write matcher in the method brought by Peasy.</p>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If you like, you can add a faster version for every matcher, which do not pass @start as parameter
Don&#39;t use the faster version in orp(exps...)!!!</p>

            </div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>match one character</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">char</span></span> = (c) -&gt; (start) -&gt;
  <span class="keyword">if</span> text[start]==c <span class="keyword">then</span> cursor = start+<span class="number">1</span>; <span class="keyword">return</span> c

exports.<span class="function"><span class="title">char_</span></span> = (c) -&gt; () -&gt;
  <span class="keyword">if</span> text[cursor]==c <span class="keyword">then</span> cursor++; <span class="keyword">return</span> c</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>match a literal string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.literal = <span class="function"><span class="title">literal</span></span> = (string) -&gt; (start) -&gt;
  len = string.length
  <span class="keyword">if</span> text.slice(start,  stop = start+len)==string <span class="keyword">then</span> cursor = stop; <span class="literal">true</span>

exports.literal_ = <span class="function"><span class="title">literal_</span></span> = (string) -&gt; (start) -&gt;
  len = string.length
  <span class="keyword">if</span> text.slice(cursor,  stop = cursor+len)==string <span class="keyword">then</span> cursor = stop; <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>In spaces, spaces<em>, spaces1, spaces1</em>, a tat(&#39;\t&#39;) is seen as tabWidth spaces,
which is used in indent style language, such as coffeescript, python, haskell, etc.
If you don&#39;t need this feature, you can rewrite these utilities to remove the code about tab width by yourself easily.</p>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>zero or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">spaces</span></span> = (start) -&gt;
  len = <span class="number">0</span>
  cursor = start
  text = text
  <span class="keyword">while</span> <span class="number">1</span>
    <span class="keyword">switch</span> text[cursor++]
      <span class="keyword">when</span> <span class="string">' '</span> <span class="keyword">then</span> len++
      <span class="keyword">when</span> <span class="string">'\t'</span> <span class="keyword">then</span> len += tabWidth
      <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="keyword">return</span> len</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter
zero or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.spaces_ = () -&gt;
  len = <span class="number">0</span>
  text = text
  <span class="keyword">while</span> <span class="number">1</span>
    <span class="keyword">switch</span> text[cursor++]
      <span class="keyword">when</span> <span class="string">' '</span> <span class="keyword">then</span> len++
      <span class="keyword">when</span> <span class="string">'\t'</span> <span class="keyword">then</span> len += tabWidth
      <span class="keyword">else</span> <span class="keyword">break</span>
  len</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>one or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">spaces1</span></span> = (start) -&gt;
  len = <span class="number">0</span>
  cursor = start
  text = text
  <span class="keyword">while</span> <span class="number">1</span>
    <span class="keyword">switch</span> text[cursor++]
      <span class="keyword">when</span> <span class="string">' '</span> <span class="keyword">then</span> len++
      <span class="keyword">when</span> <span class="string">'\t'</span> <span class="keyword">then</span> len += tabWidth
      <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="keyword">if</span> len <span class="keyword">then</span> <span class="keyword">return</span> cursor = cursor; len</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter
one or more whitespaces, ie. space or tab.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.spaces1_ = () -&gt;
  len = <span class="number">0</span>
  cursor = start
  <span class="keyword">while</span> <span class="number">1</span>
    <span class="keyword">switch</span> text[cursor++]
      <span class="keyword">when</span> <span class="string">' '</span> <span class="keyword">then</span> len++
      <span class="keyword">when</span> <span class="string">'\t'</span> <span class="keyword">then</span> len += tabWidth
      <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="keyword">if</span> len <span class="keyword">then</span> <span class="keyword">return</span> cursor = cursor; len

exports.<span class="function"><span class="title">wrap</span></span> = (item, left=spaces, right=spaces) -&gt;
  <span class="keyword">if</span> isString(item) <span class="keyword">then</span> item = literal(item)
  (start) -&gt;
     <span class="keyword">if</span> left(start) <span class="keyword">and</span> result = item(cursor) <span class="keyword">and</span> right(cursor) <span class="keyword">then</span> result

exports.getcursor = exports.cur = () -&gt; cursor

exports.setcursor = exports.<span class="function"><span class="title">setcur</span></span> = (pos) -&gt; cursor = pos</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>is a letter used in identifer?
follow word such as return, break, etc.
javascript style, &#39;$&#39; is a identifierLetter_</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">identifierLetter</span></span> = (start) -&gt;
  start = cursor
  c = text[cursor]
  <span class="keyword">if</span> c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>
    cursor++; <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>is a letter used in identifer?
javascript style, &#39;$&#39; is a identifierLetter_</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>identifierLetter_ = () -&gt;
  c = text[cursor]
  <span class="keyword">if</span> c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>
    cursor++; <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>lookahead whether the following character is a letter used in identifer, don&#39;t change cursor?
javascript style, &#39;$&#39; is a identifierLetter_</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>followIdentifierLetter_ = () -&gt;
  c = text[cursor]
  c <span class="keyword">is</span> <span class="string">'$'</span> <span class="keyword">or</span> c <span class="keyword">is</span> <span class="string">'_'</span> <span class="keyword">or</span> <span class="string">'a'</span>&lt;=c&lt;<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>

<span class="function"><span class="title">isIdentifierLetter</span></span> = (c) -&gt; <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span>

ObjecttoString = Object.prototype.toString
exports.isString = <span class="function"><span class="title">isString</span></span> = (x) -&gt; ObjecttoString.call(x) <span class="keyword">is</span> <span class="string">'[object String]'</span>

exports.<span class="function"><span class="title">isdigit</span></span> = (c) -&gt; <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span>
exports.<span class="function"><span class="title">digit</span></span> = (start) -&gt;
  c = text[start];  <span class="keyword">if</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">then</span> cursor = start+<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.digit_ = () -&gt;
  c = text[cursor];  <span class="keyword">if</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">then</span> cursor++

exports.isletter = exports.<span class="function"><span class="title">isalpha</span></span> = (c) -&gt; <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>
exports.letter = exports.<span class="function"><span class="title">alpha</span></span> = (start) -&gt;
  c = text[start]; <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">then</span> cursor = start+<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.letter_ = exports.alpha_ = () -&gt;
  c = text[cursor]; <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">then</span> cursor++

exports.<span class="function"><span class="title">islower</span></span> = (c) -&gt; <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span>
exports.<span class="function"><span class="title">lower</span></span> = (start) -&gt;
  c = text[start]; <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">then</span> cursor = start+<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.lower_ = () -&gt;
  c = text[cursor]; <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">then</span> cursor++

exports.<span class="function"><span class="title">isupper</span></span> = (c) -&gt;<span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span>
exports.<span class="function"><span class="title">upper</span></span> = (start) -&gt;
  c = text[start]; <span class="keyword">if</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">then</span> cursor = start+<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">upper_</span></span> = (start) -&gt;
  c = text[cursor]; <span class="keyword">if</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">then</span> cursor++

exports.<span class="function"><span class="title">identifier</span></span> = (start) -&gt;
  cursor = start
  c = text[cursor]
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span> <span class="keyword">then</span> cursor++
  <span class="keyword">else</span> <span class="keyword">return</span>
  <span class="keyword">while</span> <span class="number">1</span>
    c = text[cursor]
    <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span> <span class="keyword">then</span> cursor++
    <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>faster version, do not pass @start as parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>exports.<span class="function"><span class="title">identifier</span></span> = (start) -&gt;
  c = text[cursor]
  <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span> <span class="keyword">then</span> cursor++
  <span class="keyword">else</span> <span class="keyword">return</span>
  <span class="keyword">while</span> <span class="number">1</span>
    c = text[cursor]
    <span class="keyword">if</span> <span class="string">'a'</span>&lt;=c&lt;=<span class="string">'z'</span> <span class="keyword">or</span> <span class="string">'A'</span>&lt;=c&lt;=<span class="string">'Z'</span> <span class="keyword">or</span> <span class="string">'0'</span>&lt;=c&lt;=<span class="string">'9'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'$'</span> <span class="keyword">or</span> <span class="string">'c'</span>==<span class="string">'_'</span> <span class="keyword">then</span> cursor++
    <span class="keyword">else</span> <span class="keyword">break</span>
  <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>some utilities used by the parser</p>

            </div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>The untilites above is just for providing some examples on how to write matchers for Peasy.
In fact, It&#39;s realy easy peasy to write any matchers for your grammar.
<a href="http://en.wiktionary.org/wiki/easy_peasy">http://en.wiktionary.org/wiki/easy_peasy</a>
you can embedde your grammar rules with other features seamless,
such as lexer, rewriter, semantic action, error process( error reporting, error recovering)
you can dynamicly modify your parser&#39;s grammar rules, dynamic update the parsed text, if you wish.</p>

            </div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>With the method provided by Peasy, you can parse stream which is not text or stream,
including list, binary stream, or other data structure, like tree, graph, and so on.</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
